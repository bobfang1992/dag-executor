// C++ code generators

import type {
  KeyEntry,
  ParamEntry,
  FeatureEntry,
  CapabilityEntry,
  ValidationRules,
  Status,
  CapabilityStatus,
} from "./types.js";

// =====================================================
// C++ Type Helpers
// =====================================================

function cppType(t: string): string {
  switch (t) {
    case "int": return "Int";
    case "float": return "Float";
    case "string": return "String";
    case "bool": return "Bool";
    case "feature_bundle": return "FeatureBundle";
    default: return "Unknown";
  }
}

function cppStatus(s: Status): string {
  switch (s) {
    case "active": return "Active";
    case "deprecated": return "Deprecated";
    case "blocked": return "Blocked";
  }
}

function cppCapabilityStatus(s: CapabilityStatus): string {
  switch (s) {
    case "implemented": return "Implemented";
    case "draft": return "Draft";
    case "deprecated": return "Deprecated";
    case "blocked": return "Blocked";
  }
}

function cppPropertyType(jsonType: string | undefined): string {
  switch (jsonType) {
    case "boolean": return "Boolean";
    case "string": return "String";
    case "number": return "Number";
    case "array": return "Array";
    case "object": return "Object";
    default: return "Unknown";
  }
}

function cppCapabilityIdent(id: string): string {
  let ident = id.replace(/[^a-zA-Z0-9]/g, "_");
  if (/^[0-9]/.test(ident)) {
    ident = "_" + ident;
  }
  return ident;
}

// =====================================================
// Keys Header Generation
// =====================================================

export function generateKeysH(keys: KeyEntry[], digest: string): string {
  const lines: string[] = [
    "// AUTO-GENERATED - DO NOT EDIT",
    "// Generated by dsl/src/codegen.ts",
    "#pragma once",
    "",
    "#include <cstdint>",
    "#include <string_view>",
    "#include <array>",
    "",
    "namespace rankd {",
    "",
    "enum class KeyId : uint32_t {",
  ];

  for (const k of keys) {
    lines.push(`    ${k.name} = ${k.key_id},`);
  }

  lines.push("};");
  lines.push("");
  lines.push("// Helper to convert KeyId to uint32_t (avoids verbose static_cast)");
  lines.push("constexpr uint32_t key_id(KeyId k) noexcept {");
  lines.push("  return static_cast<uint32_t>(k);");
  lines.push("}");
  lines.push("");
  lines.push("enum class KeyType { Int, Float, String, Bool, FeatureBundle };");
  lines.push("enum class Status { Active, Deprecated, Blocked };")
  lines.push("");
  lines.push("struct KeyMeta {");
  lines.push("    uint32_t id;");
  lines.push("    std::string_view name;");
  lines.push("    KeyType type;");
  lines.push("    bool nullable;");
  lines.push("    Status status;");
  lines.push("    bool allow_read;");
  lines.push("    bool allow_write;");
  lines.push("    uint32_t replaced_by;  // 0 if none");
  lines.push("    bool has_default;");
  lines.push("    std::string_view default_json;");
  lines.push("};");
  lines.push("");
  lines.push(`inline constexpr size_t kKeyCount = ${keys.length};`);
  lines.push(`inline constexpr std::string_view kKeyRegistryDigest = "${digest}";`);
  lines.push("");
  lines.push("inline constexpr std::array<KeyMeta, kKeyCount> kKeyRegistry = {{");

  for (const k of keys) {
    const defaultJson = k.default !== null ? JSON.stringify(JSON.stringify(k.default)) : '""';
    lines.push(`    {${k.key_id}, "${k.name}", KeyType::${cppType(k.type)}, ${k.nullable}, Status::${cppStatus(k.status)}, ${k.allow_read}, ${k.allow_write}, ${k.replaced_by ?? 0}, ${k.default !== null}, ${defaultJson}},`);
  }

  lines.push("}};");
  lines.push("");
  lines.push("} // namespace rankd");
  lines.push("");

  return lines.join("\n");
}

// =====================================================
// Params Header Generation
// =====================================================

export function generateParamsH(params: ParamEntry[], digest: string): string {
  const lines: string[] = [
    "// AUTO-GENERATED - DO NOT EDIT",
    "// Generated by dsl/src/codegen.ts",
    "#pragma once",
    "",
    "#include <array>",
    "#include <cstdint>",
    "#include <string_view>",
    "",
    '#include "key_registry.h"  // for Status',
    "",
    "namespace rankd {",
    "",
    "enum class ParamId : uint32_t {",
  ];

  for (const p of params) {
    lines.push(`    ${p.name} = ${p.param_id},`);
  }

  lines.push("};");
  lines.push("");
  lines.push("enum class ParamType { Int, Float, String, Bool };");
  lines.push("");
  lines.push("struct ParamMeta {");
  lines.push("    uint32_t id;");
  lines.push("    std::string_view name;");
  lines.push("    ParamType type;");
  lines.push("    bool nullable;");
  lines.push("    Status status;");
  lines.push("    bool allow_read;");
  lines.push("    bool allow_write;");
  lines.push("    uint32_t replaced_by;  // 0 if none");
  lines.push("};");
  lines.push("");
  lines.push(`inline constexpr size_t kParamCount = ${params.length};`);
  lines.push(`inline constexpr std::string_view kParamRegistryDigest = "${digest}";`);
  lines.push("");
  lines.push("inline constexpr std::array<ParamMeta, kParamCount> kParamRegistry = {{");

  for (const p of params) {
    lines.push(`    {${p.param_id}, "${p.name}", ParamType::${cppType(p.type)}, ${p.nullable}, Status::${cppStatus(p.status)}, ${p.allow_read}, ${p.allow_write}, ${p.replaced_by ?? 0}},`);
  }

  lines.push("}};");
  lines.push("");
  lines.push("} // namespace rankd");
  lines.push("");

  return lines.join("\n");
}

// =====================================================
// Features Header Generation
// =====================================================

export function generateFeaturesH(features: FeatureEntry[], digest: string): string {
  const lines: string[] = [
    "// AUTO-GENERATED - DO NOT EDIT",
    "// Generated by dsl/src/codegen.ts",
    "#pragma once",
    "",
    "#include <array>",
    "#include <cstdint>",
    "#include <string_view>",
    "",
    '#include "key_registry.h"  // for Status',
    "",
    "namespace rankd {",
    "",
    "enum class FeatureId : uint32_t {",
  ];

  for (const f of features) {
    lines.push(`    ${f.stage}_${f.name} = ${f.feature_id},`);
  }

  lines.push("};");
  lines.push("");
  lines.push("enum class FeatureType { Int, Float, String, Bool };");
  lines.push("");
  lines.push("struct FeatureMeta {");
  lines.push("    uint32_t id;");
  lines.push("    std::string_view stage;");
  lines.push("    std::string_view name;");
  lines.push("    FeatureType type;");
  lines.push("    bool nullable;");
  lines.push("    Status status;");
  lines.push("};");
  lines.push("");
  lines.push(`inline constexpr size_t kFeatureCount = ${features.length};`);
  lines.push(`inline constexpr std::string_view kFeatureRegistryDigest = "${digest}";`);
  lines.push("");
  lines.push("inline constexpr std::array<FeatureMeta, kFeatureCount> kFeatureRegistry = {{");

  for (const f of features) {
    lines.push(`    {${f.feature_id}, "${f.stage}", "${f.name}", FeatureType::${cppType(f.type)}, ${f.nullable}, Status::${cppStatus(f.status)}},`);
  }

  lines.push("}};");
  lines.push("");
  lines.push("} // namespace rankd");
  lines.push("");

  return lines.join("\n");
}

// =====================================================
// Validation Header Generation
// =====================================================

export function generateValidationH(validation: ValidationRules, digest: string): string {
  const lines: string[] = [
    "// AUTO-GENERATED - DO NOT EDIT",
    "// Generated by dsl/src/codegen.ts from registry/validation.toml",
    "#pragma once",
    "",
    "#include <array>",
    "#include <cstdint>",
    "#include <regex>",
    "#include <string>",
    "#include <string_view>",
    "",
    "namespace rankd {",
    "namespace validation {",
    "",
    "// =====================================================",
    "// Patterns",
    "// =====================================================",
    "",
  ];

  for (const [name, pattern] of Object.entries(validation.patterns)) {
    const escapedPattern = pattern.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
    lines.push(`inline const std::string k${name.split("_").map(w => w[0].toUpperCase() + w.slice(1)).join("")}Pattern = "${escapedPattern}";`);
  }

  lines.push("");
  lines.push("// =====================================================");
  lines.push("// Validation functions");
  lines.push("// =====================================================");
  lines.push("");

  for (const [name] of Object.entries(validation.patterns)) {
    const fnName = `is_valid_${name}`;
    const patternVar = `k${name.split("_").map(w => w[0].toUpperCase() + w.slice(1)).join("")}Pattern`;
    lines.push(`inline bool ${fnName}(const std::string& value) {`);
    lines.push(`    static const std::regex pattern(${patternVar});`);
    lines.push(`    return std::regex_match(value, pattern);`);
    lines.push("}");
    lines.push("");
  }

  lines.push("// =====================================================");
  lines.push("// Limits");
  lines.push("// =====================================================");
  lines.push("");

  for (const [name, value] of Object.entries(validation.limits)) {
    const constName = `k${name.split("_").map(w => w[0].toUpperCase() + w.slice(1)).join("")}`;
    const cType = value > 2147483647 ? "uint64_t" : "uint32_t";
    lines.push(`inline constexpr ${cType} ${constName} = ${value};`);
  }

  lines.push("");
  lines.push("// =====================================================");
  lines.push("// Enums");
  lines.push("// =====================================================");
  lines.push("");

  for (const [name, values] of Object.entries(validation.enums)) {
    const constName = `k${name.split("_").map(w => w[0].toUpperCase() + w.slice(1)).join("")}`;
    lines.push(`inline constexpr std::array<std::string_view, ${values.length}> ${constName} = {{`);
    for (const v of values) {
      lines.push(`    ${JSON.stringify(v)},`);
    }
    lines.push("}};");
    lines.push("");
  }

  lines.push(`inline constexpr std::string_view kValidationDigest = "${digest}";`);
  lines.push("");
  lines.push("} // namespace validation");
  lines.push("} // namespace rankd");
  lines.push("");

  return lines.join("\n");
}

// =====================================================
// Capabilities Header Generation
// =====================================================

export function generateCapabilitiesH(capabilities: CapabilityEntry[], digest: string): string {
  const lines: string[] = [
    "// AUTO-GENERATED - DO NOT EDIT",
    "// Generated by dsl/src/codegen.ts from registry/capabilities.toml",
    "#pragma once",
    "",
    "#include <array>",
    "#include <optional>",
    "#include <string_view>",
    "",
    "namespace rankd {",
    "",
    "enum class CapabilityStatus { Implemented, Draft, Deprecated, Blocked };",
    "enum class PropertyType { Boolean, String, Number, Array, Object, Unknown };",
    "",
    "// Property metadata for type checking",
    "struct PropertyMeta {",
    "  std::string_view name;",
    "  PropertyType type;",
    "};",
    "",
    "// Simple schema representation (subset of JSON Schema)",
    "struct PayloadSchema {",
    "  bool has_schema;                          // false = no payload allowed",
    "  bool additional_properties;               // true = allow extra keys",
    "  const std::string_view* allowed_keys;     // pointer to array of allowed property names",
    "  size_t num_allowed_keys;                  // number of allowed properties",
    "  const std::string_view* required_keys;    // pointer to array of required property names",
    "  size_t num_required_keys;                 // number of required properties",
    "  const PropertyMeta* property_types;       // pointer to array of property type info",
    "  size_t num_property_types;                // number of property type entries",
    "};",
    "",
    "struct CapabilityMeta {",
    "  std::string_view id;",
    "  std::string_view rfc;",
    "  std::string_view name;",
    "  CapabilityStatus status;",
    "  std::string_view doc;",
    "  PayloadSchema schema;",
    "};",
    "",
  ];

  // Generate arrays for each capability
  for (const cap of capabilities) {
    const props = cap.payload_schema?.properties;
    const required = cap.payload_schema?.required;
    const propNames = props ? Object.keys(props).sort() : [];
    const ident = cppCapabilityIdent(cap.id);

    if (propNames.length > 0) {
      const varName = `kProps_${ident}`;
      lines.push(`inline constexpr std::array<std::string_view, ${propNames.length}> ${varName} = {{`);
      for (const name of propNames) {
        lines.push(`    ${JSON.stringify(name)},`);
      }
      lines.push("}};");
      lines.push("");
    }

    if (required && required.length > 0) {
      const varName = `kRequired_${ident}`;
      lines.push(`inline constexpr std::array<std::string_view, ${required.length}> ${varName} = {{`);
      for (const name of required) {
        lines.push(`    ${JSON.stringify(name)},`);
      }
      lines.push("}};");
      lines.push("");
    }

    if (props && propNames.length > 0) {
      const varName = `kPropTypes_${ident}`;
      lines.push(`inline constexpr std::array<PropertyMeta, ${propNames.length}> ${varName} = {{`);
      for (const name of propNames) {
        const propSchema = props[name];
        const propType = cppPropertyType(propSchema?.type);
        lines.push(`    {${JSON.stringify(name)}, PropertyType::${propType}},`);
      }
      lines.push("}};");
      lines.push("");
    }
  }

  lines.push(`inline constexpr size_t kCapabilityCount = ${capabilities.length};`);
  lines.push(`inline constexpr std::string_view kCapabilityRegistryDigest = "${digest}";`);
  lines.push("");
  lines.push(`inline constexpr std::array<CapabilityMeta, kCapabilityCount> kCapabilityRegistry = {{`);

  for (const cap of capabilities) {
    const hasSchema = cap.payload_schema !== null;
    const additionalProps = cap.payload_schema?.additionalProperties !== false;
    const props = cap.payload_schema?.properties;
    const required = cap.payload_schema?.required;
    const propNames = props ? Object.keys(props).sort() : [];
    const numProps = propNames.length;
    const numRequired = required?.length ?? 0;
    const ident = cppCapabilityIdent(cap.id);

    const propsPtr = numProps > 0 ? `kProps_${ident}.data()` : "nullptr";
    const requiredPtr = numRequired > 0 ? `kRequired_${ident}.data()` : "nullptr";
    const propTypesPtr = numProps > 0 ? `kPropTypes_${ident}.data()` : "nullptr";

    lines.push(`    {${JSON.stringify(cap.id)}, ${JSON.stringify(cap.rfc)}, ${JSON.stringify(cap.name)},`);
    lines.push(`     CapabilityStatus::${cppCapabilityStatus(cap.status)},`);
    lines.push(`     ${JSON.stringify(cap.doc)},`);
    lines.push(`     {.has_schema = ${hasSchema},`);
    lines.push(`      .additional_properties = ${additionalProps},`);
    lines.push(`      .allowed_keys = ${propsPtr},`);
    lines.push(`      .num_allowed_keys = ${numProps},`);
    lines.push(`      .required_keys = ${requiredPtr},`);
    lines.push(`      .num_required_keys = ${numRequired},`);
    lines.push(`      .property_types = ${propTypesPtr},`);
    lines.push(`      .num_property_types = ${numProps}}},`);
  }

  lines.push("}};");
  lines.push("");
  lines.push("} // namespace rankd");
  lines.push("");

  return lines.join("\n");
}
