// TypeScript code generators

import type {
  KeyEntry,
  ParamEntry,
  FeatureEntry,
  CapabilityEntry,
  ValidationRules,
  TaskRegistry,
  TaskEntry,
  TaskParamEntry,
} from "./types.js";
import { friendlyParamName, opToInterfaceName, opToMethodName } from "./utils.js";

// =====================================================
// Keys TypeScript Generation
// =====================================================

export function generateKeysTs(keys: KeyEntry[], digest: string): string {
  const lines: string[] = [
    "// AUTO-GENERATED - DO NOT EDIT",
    "// Generated by dsl/src/codegen.ts",
    "",
    'export type KeyType = "int" | "float" | "string" | "bool" | "feature_bundle";',
    "",
    "export interface KeyToken {",
    '  readonly kind: "Key";',
    "  readonly id: number;",
    "  readonly name: string;",
    "}",
    "",
    "function key(id: number, name: string): KeyToken {",
    '  return { kind: "Key", id, name };',
    "}",
    "",
    "export const Key = {",
  ];

  for (const k of keys) {
    lines.push(`  ${k.name}: key(${k.key_id}, "${k.name}"),`);
  }

  lines.push("} as const;");
  lines.push("");
  lines.push(`export const KEY_REGISTRY_DIGEST = "${digest}";`);
  lines.push(`export const KEY_COUNT = ${keys.length};`);
  lines.push("");

  return lines.join("\n");
}

// =====================================================
// Params TypeScript Generation
// =====================================================

export function generateParamsTs(params: ParamEntry[], digest: string): string {
  const lines: string[] = [
    "// AUTO-GENERATED - DO NOT EDIT",
    "// Generated by dsl/src/codegen.ts",
    "",
    'export type ParamType = "int" | "float" | "string" | "bool";',
    "",
    "export interface ParamToken {",
    '  readonly kind: "Param";',
    "  readonly id: number;",
    "  readonly name: string;",
    "}",
    "",
    "function param(id: number, name: string): ParamToken {",
    '  return { kind: "Param", id, name };',
    "}",
    "",
    "export const P = {",
  ];

  for (const p of params) {
    lines.push(`  ${p.name}: param(${p.param_id}, "${p.name}"),`);
  }

  lines.push("} as const;");
  lines.push("");
  lines.push(`export const PARAM_REGISTRY_DIGEST = "${digest}";`);
  lines.push(`export const PARAM_COUNT = ${params.length};`);
  lines.push("");

  return lines.join("\n");
}

// =====================================================
// Features TypeScript Generation
// =====================================================

export function generateFeaturesTs(features: FeatureEntry[], digest: string): string {
  const lines: string[] = [
    "// AUTO-GENERATED - DO NOT EDIT",
    "// Generated by dsl/src/codegen.ts",
    "",
    'export type FeatureType = "int" | "float" | "string" | "bool";',
    "",
    "export interface FeatureToken {",
    '  readonly kind: "Feature";',
    "  readonly id: number;",
    "  readonly stage: string;",
    "  readonly name: string;",
    "}",
    "",
    "function feat(id: number, stage: string, name: string): FeatureToken {",
    '  return { kind: "Feature", id, stage, name };',
    "}",
    "",
  ];

  // Group by stage
  const byStage = new Map<string, FeatureEntry[]>();
  for (const f of features) {
    if (!byStage.has(f.stage)) byStage.set(f.stage, []);
    byStage.get(f.stage)!.push(f);
  }

  const stages = Array.from(byStage.keys()).sort();

  lines.push("export const Feat = {");
  for (const stage of stages) {
    const feats = byStage.get(stage)!;
    lines.push(`  ${stage}: {`);
    for (const f of feats) {
      lines.push(`    ${f.name}: feat(${f.feature_id}, "${f.stage}", "${f.name}"),`);
    }
    lines.push("  },");
  }
  lines.push("} as const;");
  lines.push("");
  lines.push(`export const FEATURE_REGISTRY_DIGEST = "${digest}";`);
  lines.push(`export const FEATURE_COUNT = ${features.length};`);
  lines.push("");

  return lines.join("\n");
}

// =====================================================
// Index TypeScript Generation
// =====================================================

export function generateIndexTs(): string {
  return [
    "// AUTO-GENERATED - DO NOT EDIT",
    "// Generated by dsl/src/codegen.ts",
    "",
    "// Re-export values and types separately for isolatedModules compatibility",
    'export { Key, KEY_REGISTRY_DIGEST, KEY_COUNT } from "./keys.js";',
    'export type { KeyToken, KeyType } from "./keys.js";',
    'export { P, PARAM_REGISTRY_DIGEST, PARAM_COUNT } from "./params.js";',
    'export type { ParamToken, ParamType } from "./params.js";',
    'export { Feat, FEATURE_REGISTRY_DIGEST, FEATURE_COUNT } from "./features.js";',
    'export type { FeatureToken, FeatureType } from "./features.js";',
    'export * from "./validation.js";',
    'export * from "./capabilities.js";',
    'export * from "./endpoints.js";',
    'export * from "./tasks.js";',
    'export * from "./task-impl.js";',
    'export { DSL_TYPES } from "./monaco-types.js";',
    "",
  ].join("\n");
}

// =====================================================
// Validation TypeScript Generation
// =====================================================

export function generateValidationTs(validation: ValidationRules, digest: string): string {
  const lines: string[] = [
    "// AUTO-GENERATED - DO NOT EDIT",
    "// Generated by dsl/src/codegen.ts from registry/validation.toml",
    "",
    "export interface ValidationRules {",
    "  schemaVersion: number;",
    "  patterns: Record<string, RegExp>;",
    "  limits: Record<string, number>;",
    "  enums: Record<string, readonly string[]>;",
    "}",
    "",
    "export const Validation: ValidationRules = {",
    `  schemaVersion: ${validation.schema_version},`,
    "  patterns: {",
  ];

  for (const [name, pattern] of Object.entries(validation.patterns)) {
    lines.push(`    ${name}: /${pattern}/,`);
  }

  lines.push("  },");
  lines.push("  limits: {");

  for (const [name, value] of Object.entries(validation.limits)) {
    lines.push(`    ${name}: ${value},`);
  }

  lines.push("  },");
  lines.push("  enums: {");

  for (const [name, values] of Object.entries(validation.enums)) {
    lines.push(`    ${name}: [${values.map(v => `"${v}"`).join(", ")}] as const,`);
  }

  lines.push("  },");
  lines.push("};");
  lines.push("");
  lines.push(`export const VALIDATION_DIGEST = "${digest}";`);
  lines.push("");

  // Generate validation helper functions for patterns
  lines.push("// Validation helper functions");
  for (const name of Object.keys(validation.patterns)) {
    // Convert snake_case to camelCase for function name: plan_name -> PlanName
    const fnName = name
      .split("_")
      .map(part => part.charAt(0).toUpperCase() + part.slice(1))
      .join("");
    lines.push(`export function isValid${fnName}(value: string): boolean {`);
    lines.push(`  return Validation.patterns.${name}.test(value);`);
    lines.push("}");
    lines.push("");
  }

  return lines.join("\n");
}

// =====================================================
// Capabilities TypeScript Generation
// =====================================================

export function generateCapabilitiesTs(capabilities: CapabilityEntry[], digest: string): string {
  const lines: string[] = [
    "// AUTO-GENERATED - DO NOT EDIT",
    "// Generated by dsl/src/codegen.ts from registry/capabilities.toml",
    "",
    "export interface CapabilityMeta {",
    "  id: string;",
    "  rfc: string;",
    "  name: string;",
    '  status: "implemented" | "draft" | "deprecated" | "blocked";',
    "  doc: string;",
    "  payload_schema: unknown;  // JSON Schema or null",
    "}",
    "",
  ];

  // Generate const for each capability
  lines.push("// Capability constants");
  for (const cap of capabilities) {
    // Convert id to constant name: cap.rfc.0001.foo.v1 -> CAP_RFC_0001_FOO_V1
    const constName = cap.id.toUpperCase().replace(/\./g, "_");
    lines.push(`export const ${constName} = "${cap.id}";`);
  }
  lines.push("");

  // Generate registry object
  lines.push("export const CapabilityRegistry: Record<string, CapabilityMeta> = {");
  for (const cap of capabilities) {
    lines.push(`  "${cap.id}": {`);
    lines.push(`    id: "${cap.id}",`);
    lines.push(`    rfc: "${cap.rfc}",`);
    lines.push(`    name: "${cap.name}",`);
    lines.push(`    status: "${cap.status}",`);
    lines.push(`    doc: ${JSON.stringify(cap.doc)},`);
    lines.push(`    payload_schema: ${cap.payload_schema ? JSON.stringify(cap.payload_schema) : "null"},`);
    lines.push(`  },`);
  }
  lines.push("};");
  lines.push("");

  // Generate list of all capability IDs
  lines.push("export const ALL_CAPABILITY_IDS = [");
  for (const cap of capabilities) {
    lines.push(`  "${cap.id}",`);
  }
  lines.push("] as const;");
  lines.push("");

  // Generate set of supported capabilities (implemented + deprecated for backwards compat)
  // This matches engine behavior in capability_registry.cpp
  const supportedCaps = capabilities.filter(c => c.status === "implemented" || c.status === "deprecated");
  lines.push("/** Set of capability IDs that are supported (implemented + deprecated for backwards compat) */");
  lines.push("export const SUPPORTED_CAPABILITIES = new Set([");
  for (const cap of supportedCaps) {
    lines.push(`  "${cap.id}",`);
  }
  lines.push("]);");
  lines.push("");

  lines.push(`export const CAPABILITY_REGISTRY_DIGEST = "${digest}";`);
  lines.push(`export const CAPABILITY_COUNT = ${capabilities.length};`);
  lines.push("");

  // Generate validatePayload function
  lines.push("/**");
  lines.push(" * Validate that a capability payload matches its schema.");
  lines.push(" * Returns null if valid, error message if invalid.");
  lines.push(" */");
  lines.push("export function validatePayload(capId: string, payload: unknown): string | null {");
  lines.push("  const meta = CapabilityRegistry[capId];");
  lines.push("  if (!meta) return `Unknown capability: ${capId}`;");
  lines.push("");
  lines.push("  const schema = meta.payload_schema as { type?: string; properties?: Record<string, unknown>; additionalProperties?: boolean } | null;");
  lines.push("");
  lines.push("  // null schema means no payload allowed (only undefined/null accepted)");
  lines.push("  if (schema === null) {");
  lines.push("    if (payload !== undefined && payload !== null) {");
  lines.push("      return `Capability ${capId} does not allow a payload`;");
  lines.push("    }");
  lines.push("    return null;");
  lines.push("  }");
  lines.push("");
  lines.push("  // Validate object type (reject arrays, null, non-objects)");
  lines.push('  if (schema.type === "object") {');
  lines.push('    if (typeof payload !== "object" || payload === null || Array.isArray(payload)) {');
  lines.push("      return `Capability ${capId} payload must be an object`;");
  lines.push("    }");
  lines.push("");
  lines.push("    const payloadObj = payload as Record<string, unknown>;");
  lines.push("    const schemaFull = schema as {");
  lines.push("      properties?: Record<string, { type?: string }>;");
  lines.push("      required?: string[];");
  lines.push("      additionalProperties?: boolean;");
  lines.push("    };");
  lines.push("");
  lines.push("    // Check additionalProperties: false");
  lines.push("    if (schemaFull.additionalProperties === false) {");
  lines.push("      const allowedKeys = new Set(schemaFull.properties ? Object.keys(schemaFull.properties) : []);");
  lines.push("      for (const key of Object.keys(payloadObj)) {");
  lines.push("        if (!allowedKeys.has(key)) {");
  lines.push("          return `Capability ${capId} payload has unexpected property: ${key}`;");
  lines.push("        }");
  lines.push("      }");
  lines.push("    }");
  lines.push("");
  lines.push("    // Check required properties");
  lines.push("    if (schemaFull.required) {");
  lines.push("      for (const key of schemaFull.required) {");
  lines.push("        if (!(key in payloadObj)) {");
  lines.push("          return `Capability ${capId} payload missing required property: ${key}`;");
  lines.push("        }");
  lines.push("      }");
  lines.push("    }");
  lines.push("");
  lines.push("    // Check property types");
  lines.push("    if (schemaFull.properties) {");
  lines.push("      for (const [key, propSchema] of Object.entries(schemaFull.properties)) {");
  lines.push("        if (key in payloadObj && propSchema.type) {");
  lines.push("          const value = payloadObj[key];");
  lines.push("          // typeof null === 'object', so check null explicitly");
  lines.push("          const actualType = value === null ? \"null\" : Array.isArray(value) ? \"array\" : typeof value;");
  lines.push("          // Normalize JSON Schema 'integer' to 'number' for comparison");
  lines.push("          const expectedType = propSchema.type === \"integer\" ? \"number\" : propSchema.type;");
  lines.push("          if (expectedType !== actualType) {");
  lines.push("            return `Capability ${capId} payload property ${key} must be ${propSchema.type}, got ${actualType}`;");
  lines.push("          }");
  lines.push("        }");
  lines.push("      }");
  lines.push("    }");
  lines.push("  }");
  lines.push("");
  lines.push("  return null;");
  lines.push("}");
  lines.push("");

  return lines.join("\n");
}

// =====================================================
// Tasks TypeScript Generation
// =====================================================

/**
 * Convert C++ param type to TypeScript type
 */
function paramTypeToTsType(param: TaskParamEntry): string {
  const { type, nullable } = param;

  let baseType: string;
  switch (type) {
    case "int":
      // Special case: key references are KeyToken (out_key for vm, by for sort)
      if (param.name === "out_key" || param.name === "by") {
        baseType = "KeyToken";
      } else {
        baseType = "number";
      }
      break;
    case "float":
      baseType = "number";
      break;
    case "bool":
      baseType = "boolean";
      break;
    case "string":
      baseType = "string";
      break;
    case "expr_id":
      baseType = "ExprInput";
      break;
    case "pred_id":
      baseType = "PredInput";
      break;
    case "node_ref":
      baseType = "CandidateSetLike";
      break;
    case "endpoint_ref":
      baseType = "EndpointId";
      break;
    default:
      baseType = "unknown";
  }

  // Nullable types: add " | null" to maintain parity with C++ validation
  if (nullable) {
    return `${baseType} | null`;
  }

  return baseType;
}

export function generateTasksTs(registry: TaskRegistry): string {
  // Check if any tasks use endpoint_ref params
  const hasEndpointRef = registry.tasks.some((task) =>
    task.params.some((p) => p.type === "endpoint_ref")
  );

  const lines: string[] = [
    "// AUTO-GENERATED from C++ TaskSpec - DO NOT EDIT",
    "// Generated by dsl/src/codegen.ts from registry/tasks.toml",
    '// Regenerate with: pnpm -C dsl run gen',
    "",
    'import type { KeyToken } from "./keys.js";',
  ];

  if (hasEndpointRef) {
    lines.push('import type { EndpointId } from "./endpoints.js";');
  }

  lines.push(
    "",
    "// =====================================================",
    "// Expression types (narrow discriminated unions)",
    "// =====================================================",
    "",
    "/** ExprNode - matches engine's ExprIR format (builder-style) */",
    "export type ExprNode =",
    '  | { op: "const_number"; value: number }',
    '  | { op: "const_null" }',
    '  | { op: "key_ref"; key_id: number }',
    '  | { op: "param_ref"; param_id: number }',
    '  | { op: "add"; a: ExprNode; b: ExprNode }',
    '  | { op: "sub"; a: ExprNode; b: ExprNode }',
    '  | { op: "mul"; a: ExprNode; b: ExprNode }',
    '  | { op: "neg"; x: ExprNode }',
    '  | { op: "coalesce"; a: ExprNode; b: ExprNode };',
    "",
    "/** ExprPlaceholder - compile-time placeholder for natural expression syntax */",
    "export interface ExprPlaceholder {",
    "  __expr_id: number;",
    "}",
    "",
    "/** ExprInput - expression input type for tasks (builder or natural syntax) */",
    "export type ExprInput = ExprNode | ExprPlaceholder;",
    "",
    "// =====================================================",
    "// Predicate types (narrow discriminated unions)",
    "// =====================================================",
    "",
    "/** Regex pattern - literal string or param reference */",
    "export type RegexPattern =",
    '  | { kind: "literal"; value: string }',
    '  | { kind: "param"; param_id: number };',
    "",
    "/** PredNode - matches engine's PredIR format */",
    "export type PredNode =",
    '  | { op: "const_bool"; value: boolean }',
    '  | { op: "and"; a: PredNode; b: PredNode }',
    '  | { op: "or"; a: PredNode; b: PredNode }',
    '  | { op: "not"; x: PredNode }',
    '  | { op: "cmp"; cmp: "==" | "!=" | "<" | "<=" | ">" | ">="; a: ExprNode; b: ExprNode }',
    '  | { op: "in"; lhs: ExprNode; list: (number | string)[] }',
    '  | { op: "is_null"; x: ExprNode }',
    '  | { op: "not_null"; x: ExprNode }',
    '  | { op: "regex"; key_id: number; pattern: RegexPattern; flags: string };',
    "",
    "/** PredPlaceholder - compile-time placeholder for natural predicate syntax */",
    "export interface PredPlaceholder {",
    "  __pred_id: number;",
    "}",
    "",
    "/** PredInput - predicate input type for tasks (builder or natural syntax) */",
    "export type PredInput = PredNode | PredPlaceholder;",
    "",
    "// =====================================================",
    "// Node reference types (for tasks like concat)",
    "// =====================================================",
    "",
    "/** Interface for CandidateSet used by NodeRef params (avoids circular dep with runtime) */",
    "export interface CandidateSetLike {",
    "  getNodeId(): string;",
    "}",
    ""
  );

  // Classify tasks: viewer.* are source tasks, others are transform tasks
  const sourceTasks: TaskEntry[] = [];
  const transformTasks: TaskEntry[] = [];

  for (const task of registry.tasks) {
    if (task.op.startsWith("viewer.")) {
      sourceTasks.push(task);
    } else {
      transformTasks.push(task);
    }
  }

  // Generate source task option interfaces
  if (sourceTasks.length > 0) {
    lines.push("// =====================================================");
    lines.push("// Source task option interfaces");
    lines.push("// =====================================================");
    lines.push("");

    for (const task of sourceTasks) {
      const interfaceName = opToInterfaceName(task.op);
      lines.push(`export interface ${interfaceName} {`);
      for (const param of task.params) {
        const tsName = friendlyParamName(param.name, param.type);
        const tsType = paramTypeToTsType(param);
        const optional = !param.required ? "?" : "";
        lines.push(`  ${tsName}${optional}: ${tsType};`);
      }
      // All tasks support extensions
      lines.push("  extensions?: Record<string, unknown>;");
      lines.push("}");
      lines.push("");
    }
  }

  // Generate transform task option interfaces
  if (transformTasks.length > 0) {
    lines.push("// =====================================================");
    lines.push("// Transform task option interfaces");
    lines.push("// =====================================================");
    lines.push("");

    for (const task of transformTasks) {
      const interfaceName = opToInterfaceName(task.op);
      lines.push(`export interface ${interfaceName} {`);
      for (const param of task.params) {
        const tsName = friendlyParamName(param.name, param.type);
        const tsType = paramTypeToTsType(param);
        const optional = !param.required ? "?" : "";
        lines.push(`  ${tsName}${optional}: ${tsType};`);
      }
      // All tasks support extensions
      lines.push("  extensions?: Record<string, unknown>;");
      lines.push("}");
      lines.push("");
    }
  }

  // Export metadata
  lines.push("// =====================================================");
  lines.push("// Metadata");
  lines.push("// =====================================================");
  lines.push("");
  lines.push(`export const TASK_MANIFEST_DIGEST = "${registry.manifest_digest}";`);
  lines.push(`export const TASK_COUNT = ${registry.tasks.length};`);
  lines.push("");

  // Generate task extraction metadata for AST extractor
  lines.push("// =====================================================");
  lines.push("// Task extraction metadata (for AST extractor)");
  lines.push("// =====================================================");
  lines.push("");
  lines.push("/** Extraction info for a task - which properties to extract as expr/pred */");
  lines.push("export interface TaskExtractionInfo {");
  lines.push("  /** Property name containing expression (for tasks with expr_id param) */");
  lines.push("  exprProp?: string;");
  lines.push("  /** Property name containing predicate (for tasks with pred_id param) */");
  lines.push("  predProp?: string;");
  lines.push("}");
  lines.push("");
  lines.push("/** Map from method name to extraction info */");
  lines.push("export const TASK_EXTRACTION_INFO: Record<string, TaskExtractionInfo> = {");

  for (const task of registry.tasks) {
    // Method name: for "viewer.foo" it's "foo", otherwise it's the op itself
    const methodName = task.op.startsWith("viewer.")
      ? task.op.slice("viewer.".length)
      : task.op;

    // Check if task has expr_id or pred_id params
    let exprProp: string | null = null;
    let predProp: string | null = null;

    for (const param of task.params) {
      if (param.type === "expr_id") {
        exprProp = friendlyParamName(param.name, param.type); // -> "expr"
      }
      if (param.type === "pred_id") {
        predProp = friendlyParamName(param.name, param.type); // -> "pred"
      }
    }

    // Only add entry if task has extraction targets
    if (exprProp || predProp) {
      const props: string[] = [];
      if (exprProp) props.push(`exprProp: "${exprProp}"`);
      if (predProp) props.push(`predProp: "${predProp}"`);
      lines.push(`  "${methodName}": { ${props.join(", ")} },`);
    }
  }

  lines.push("};");
  lines.push("");

  return lines.join("\n");
}

// =====================================================
// Task Implementation TypeScript Generation
// =====================================================

export function generateTaskImplTs(registry: TaskRegistry): string {
  const lines: string[] = [
    "// AUTO-GENERATED from C++ TaskSpec - DO NOT EDIT",
    "// Generated by dsl/src/codegen.ts from registry/tasks.toml",
    '// Regenerate with: pnpm -C dsl run gen',
    "",
    '// This file contains the generated task implementations.',
    '// It is used by plan.ts to implement task methods without manual code.',
    "",
    'import type { ExprNode, ExprPlaceholder, ExprInput, PredNode, PredPlaceholder, PredInput, CandidateSetLike } from "./tasks.js";',
    'import type { KeyToken } from "./keys.js";',
    "",
    "// =====================================================",
    "// Types for plan context interface",
    "// =====================================================",
    "",
    "/** Interface for expression placeholder detection */",
    "export function isExprPlaceholder(value: unknown): value is ExprPlaceholder {",
    "  return (",
    '    value !== null &&',
    '    typeof value === "object" &&',
    '    "__expr_id" in value &&',
    "    typeof (value as ExprPlaceholder).__expr_id === \"number\"",
    "  );",
    "}",
    "",
    "/** Interface for predicate placeholder detection */",
    "export function isPredPlaceholder(value: unknown): value is PredPlaceholder {",
    "  return (",
    '    value !== null &&',
    '    typeof value === "object" &&',
    '    "__pred_id" in value &&',
    "    typeof (value as PredPlaceholder).__pred_id === \"number\"",
    "  );",
    "}",
    "",
    "/** Interface that PlanCtx must implement for task impls to use */",
    "export interface TaskContext {",
    "  addNode(",
    "    op: string,",
    "    inputs: string[],",
    "    params: Record<string, unknown>,",
    "    extensions?: Record<string, unknown>",
    "  ): string;",
    "  addExpr(expr: ExprNode): string;",
    "  addPred(pred: PredNode): string;",
    "}",
    "",
    "// =====================================================",
    "// Validation helpers",
    "// =====================================================",
    "",
    "function assertNotUndefined<T>(value: T | undefined, name: string): asserts value is T {",
    '  if (value === undefined) throw new Error(`${name} is undefined`);',
    "}",
    "",
    "function assertInteger(value: unknown, name: string): asserts value is number {",
    "  if (typeof value !== \"number\" || !Number.isInteger(value)) {",
    "    throw new Error(`${name} must be an integer, got ${typeof value === \"number\" ? value : typeof value}`);",
    "  }",
    "}",
    "",
    "function assertKeyToken(value: unknown, name: string): void {",
    "  if (value === null || typeof value !== \"object\") {",
    "    throw new Error(`${name} must be a KeyToken, got ${value === null ? \"null\" : typeof value}`);",
    "  }",
    "  const token = value as Record<string, unknown>;",
    "  if (typeof token.id !== \"number\" || !Number.isInteger(token.id)) {",
    "    throw new Error(`${name}.id must be an integer, got ${typeof token.id === \"number\" ? token.id : typeof token.id}`);",
    "  }",
    "}",
    "",
    "function assertStringOrNull(value: unknown, name: string): void {",
    "  if (value !== null && typeof value !== \"string\") {",
    "    throw new Error(`${name} must be a string or null, got ${typeof value}`);",
    "  }",
    "}",
    "",
    "function assertExprInput(value: unknown, name: string): void {",
    "  if (value === null || typeof value !== \"object\") {",
    "    throw new Error(`${name} must be an ExprNode or ExprPlaceholder, got ${value === null ? \"null\" : typeof value}`);",
    "  }",
    "  const obj = value as Record<string, unknown>;",
    "  // ExprPlaceholder has __expr_id, ExprNode has op",
    "  if (typeof obj.__expr_id !== \"number\" && typeof obj.op !== \"string\") {",
    "    throw new Error(`${name} must be an ExprNode (with 'op') or ExprPlaceholder (with '__expr_id')`);",
    "  }",
    "}",
    "",
    "function assertPredInput(value: unknown, name: string): void {",
    "  if (value === null || typeof value !== \"object\") {",
    "    throw new Error(`${name} must be a PredNode or PredPlaceholder, got ${value === null ? \"null\" : typeof value}`);",
    "  }",
    "  const obj = value as Record<string, unknown>;",
    "  // PredPlaceholder has __pred_id, PredNode has op",
    "  if (typeof obj.__pred_id !== \"number\" && typeof obj.op !== \"string\") {",
    "    throw new Error(`${name} must be a PredNode (with 'op') or PredPlaceholder (with '__pred_id')`);",
    "  }",
    "}",
    "",
    "function assertCandidateSet(value: unknown, name: string): void {",
    "  if (value === null || typeof value !== \"object\") {",
    "    throw new Error(`${name} must be a CandidateSet, got ${value === null ? \"null\" : typeof value}`);",
    "  }",
    "  const obj = value as Record<string, unknown>;",
    "  if (typeof obj.getNodeId !== \"function\") {",
    "    throw new Error(`${name} must be a CandidateSet with 'getNodeId' method`);",
    "  }",
    "}",
    "",
    "function checkNoUndefined(obj: Record<string, unknown>, context: string): void {",
    "  for (const [key, value] of Object.entries(obj)) {",
    "    if (value === undefined) {",
    "      throw new Error(`${context}.${key} is undefined`);",
    "    }",
    "    // Recursively check nested objects (but not arrays)",
    "    if (typeof value === \"object\" && value !== null && !Array.isArray(value)) {",
    "      checkNoUndefined(value as Record<string, unknown>, `${context}.${key}`);",
    "    }",
    "  }",
    "}",
    "",
  ];

  // Classify tasks
  const sourceTasks = registry.tasks.filter(t => t.op.startsWith("viewer."));
  const transformTasks = registry.tasks.filter(t => !t.op.startsWith("viewer."));

  // Generate source task implementations
  if (sourceTasks.length > 0) {
    lines.push("// =====================================================");
    lines.push("// Source task implementations (for PlanCtx.viewer)");
    lines.push("// =====================================================");
    lines.push("");

    for (const task of sourceTasks) {
      const methodName = opToMethodName(task.op);

      lines.push(`/** Implementation for ${task.op} */`);
      lines.push(`export function ${methodName}Impl(`);
      lines.push(`  ctx: TaskContext,`);
      lines.push(`  opts: {`);

      // Generate opts type inline (same as interface but with extensions)
      for (const param of task.params) {
        const tsName = friendlyParamName(param.name, param.type);
        const tsType = paramTypeToTsType(param);
        const optional = !param.required ? "?" : "";
        lines.push(`    ${tsName}${optional}: ${tsType};`);
      }
      lines.push(`    extensions?: Record<string, unknown>;`);
      lines.push(`  }`);
      lines.push(`): string {`);

      // Generate validation
      lines.push(`  assertNotUndefined(opts, "${methodName}(opts)");`);
      for (const param of task.params) {
        if (param.required) {
          const tsName = friendlyParamName(param.name, param.type);
          lines.push(`  assertNotUndefined(opts.${tsName}, "${methodName}({ ${tsName} })");`);
          // Add type-specific validation
          if (param.type === "int") {
            lines.push(`  assertInteger(opts.${tsName}, "${methodName}({ ${tsName} })");`);
          }
        }
      }
      lines.push(`  const { extensions, ...rest } = opts;`);
      lines.push(`  checkNoUndefined(rest as Record<string, unknown>, "${methodName}(opts)");`);
      lines.push("");

      // Validate trace if present
      const hasTrace = task.params.some(p => p.name === "trace");
      if (hasTrace) {
        lines.push(`  // Validate trace`);
        lines.push(`  if (opts.trace !== undefined) {`);
        lines.push(`    assertStringOrNull(opts.trace, "${methodName}({ trace })");`);
        lines.push(`  }`);
        lines.push("");
      }

      // Generate params object
      lines.push(`  const params: Record<string, unknown> = {`);
      for (const param of task.params) {
        const tsName = friendlyParamName(param.name, param.type);
        const cppName = param.name;

        // Handle trace default
        if (param.name === "trace") {
          lines.push(`    ${cppName}: opts.${tsName} ?? null,`);
        } else {
          lines.push(`    ${cppName}: opts.${tsName},`);
        }
      }
      lines.push(`  };`);
      lines.push("");

      // Create node (source tasks have no inputs)
      lines.push(`  return ctx.addNode("${task.op}", [], params, extensions);`);
      lines.push(`}`);
      lines.push("");
    }
  }

  // Generate transform task implementations
  if (transformTasks.length > 0) {
    lines.push("// =====================================================");
    lines.push("// Transform task implementations (for CandidateSet methods)");
    lines.push("// =====================================================");
    lines.push("");

    for (const task of transformTasks) {
      const methodName = opToMethodName(task.op);

      lines.push(`/** Implementation for ${task.op} */`);
      lines.push(`export function ${methodName}Impl(`);
      lines.push(`  ctx: TaskContext,`);
      lines.push(`  inputNodeId: string,`);
      lines.push(`  opts: {`);

      // Generate opts type inline
      for (const param of task.params) {
        const tsName = friendlyParamName(param.name, param.type);
        const tsType = paramTypeToTsType(param);
        const optional = !param.required ? "?" : "";
        lines.push(`    ${tsName}${optional}: ${tsType};`);
      }
      lines.push(`    extensions?: Record<string, unknown>;`);
      lines.push(`  }`);
      lines.push(`): string {`);

      // Generate validation
      lines.push(`  assertNotUndefined(opts, "${methodName}(opts)");`);
      for (const param of task.params) {
        if (param.required) {
          const tsName = friendlyParamName(param.name, param.type);
          lines.push(`  assertNotUndefined(opts.${tsName}, "${methodName}({ ${tsName} })");`);
          // Add type-specific validation
          if (param.name === "out_key" || param.name === "by") {
            lines.push(`  assertKeyToken(opts.${tsName}, "${methodName}({ ${tsName} })");`);
          } else if (param.type === "int") {
            lines.push(`  assertInteger(opts.${tsName}, "${methodName}({ ${tsName} })");`);
          } else if (param.type === "node_ref") {
            lines.push(`  assertCandidateSet(opts.${tsName}, "${methodName}({ ${tsName} })");`);
          }
        }
      }
      lines.push(`  const { extensions, ...rest } = opts;`);
      lines.push(`  checkNoUndefined(rest as Record<string, unknown>, "${methodName}(opts)");`);
      lines.push("");

      // Handle expr_id and pred_id params
      const hasExprId = task.params.some(p => p.type === "expr_id");
      const hasPredId = task.params.some(p => p.type === "pred_id");
      const hasTrace = task.params.some(p => p.name === "trace");

      // Validate trace if present
      if (hasTrace) {
        lines.push(`  // Validate trace`);
        lines.push(`  if (opts.trace !== undefined) {`);
        lines.push(`    assertStringOrNull(opts.trace, "${methodName}({ trace })");`);
        lines.push(`  }`);
        lines.push("");
      }

      if (hasExprId) {
        // Find the param name for expr_id
        const exprParam = task.params.find(p => p.type === "expr_id")!;
        const exprTsName = friendlyParamName(exprParam.name, exprParam.type);
        lines.push(`  // Validate and handle expression table`);
        lines.push(`  assertExprInput(opts.${exprTsName}, "${methodName}({ ${exprTsName} })");`);
        lines.push(`  let exprId: string;`);
        lines.push(`  if (isExprPlaceholder(opts.${exprTsName})) {`);
        lines.push(`    // AST-extracted expression - use special prefix for later remapping`);
        lines.push(`    exprId = \`__static_e\${opts.${exprTsName}.__expr_id}\`;`);
        lines.push(`  } else {`);
        lines.push(`    // Regular builder-style expression`);
        lines.push(`    exprId = ctx.addExpr(opts.${exprTsName} as ExprNode);`);
        lines.push(`  }`);
        lines.push("");
      }

      if (hasPredId) {
        // Find the param name for pred_id
        const predParam = task.params.find(p => p.type === "pred_id")!;
        const predTsName = friendlyParamName(predParam.name, predParam.type);
        lines.push(`  // Validate and handle predicate table`);
        lines.push(`  assertPredInput(opts.${predTsName}, "${methodName}({ ${predTsName} })");`);
        lines.push(`  let predId: string;`);
        lines.push(`  if (isPredPlaceholder(opts.${predTsName})) {`);
        lines.push(`    // AST-extracted predicate - use special prefix for later remapping`);
        lines.push(`    predId = \`__static_p\${opts.${predTsName}.__pred_id}\`;`);
        lines.push(`  } else {`);
        lines.push(`    // Regular builder-style predicate`);
        lines.push(`    predId = ctx.addPred(opts.${predTsName} as PredNode);`);
        lines.push(`  }`);
        lines.push("");
      }

      // Generate params object
      lines.push(`  const params: Record<string, unknown> = {`);
      for (const param of task.params) {
        const tsName = friendlyParamName(param.name, param.type);
        const cppName = param.name;

        if (param.type === "expr_id") {
          lines.push(`    ${cppName}: exprId,`);
        } else if (param.type === "pred_id") {
          lines.push(`    ${cppName}: predId,`);
        } else if (param.type === "node_ref") {
          lines.push(`    ${cppName}: opts.${tsName}.getNodeId(),`);
        } else if (param.name === "out_key" || param.name === "by") {
          lines.push(`    ${cppName}: opts.${tsName}.id,`);
        } else if (param.name === "trace") {
          lines.push(`    ${cppName}: opts.${tsName} ?? null,`);
        } else {
          lines.push(`    ${cppName}: opts.${tsName},`);
        }
      }
      lines.push(`  };`);
      lines.push("");

      // Create node
      lines.push(`  return ctx.addNode("${task.op}", [inputNodeId], params, extensions);`);
      lines.push(`}`);
      lines.push("");
    }
  }

  // Export task registry for plan.ts to use
  lines.push("// =====================================================");
  lines.push("// Task metadata for runtime use");
  lines.push("// =====================================================");
  lines.push("");
  lines.push("export const GENERATED_TASKS = {");
  lines.push("  source: [" + sourceTasks.map(t => `"${opToMethodName(t.op)}"`).join(", ") + "],");
  lines.push("  transform: [" + transformTasks.map(t => `"${opToMethodName(t.op)}"`).join(", ") + "],");
  lines.push("} as const;");
  lines.push("");

  return lines.join("\n");
}

// =====================================================
// Plan Globals Declaration Generation
// =====================================================

export function generatePlanGlobalsDts(): string {
  return [
    "// AUTO-GENERATED - DO NOT EDIT",
    "// Generated by dsl/src/codegen.ts",
    "//",
    "// Global type declarations for plan authoring.",
    "// Key, P, coalesce, and regex are injected as globals by the dslc compiler.",
    "// This file provides TypeScript type information for editor support.",
    "",
    'import type { Key as KeyType } from "@ranking-dsl/generated";',
    'import type { P as PType } from "@ranking-dsl/generated";',
    'import type { coalesce as coalesceType, regex as regexType } from "@ranking-dsl/runtime";',
    "",
    "declare global {",
    "  /**",
    "   * Key registry - column references for vm/filter expressions.",
    "   * Injected by dslc compiler.",
    "   */",
    "  const Key: typeof KeyType;",
    "",
    "  /**",
    "   * Param registry - runtime parameter references.",
    "   * Injected by dslc compiler.",
    "   */",
    "  const P: typeof PType;",
    "",
    "  /**",
    "   * Coalesce function for null handling in natural expressions.",
    "   * Usage: Key.score * coalesce(P.weight, 0.2)",
    "   * Injected by dslc compiler.",
    "   */",
    "  const coalesce: typeof coalesceType;",
    "",
    "  /**",
    "   * Regex function for pattern matching in natural predicates.",
    "   * Usage: regex(Key.title, \"^test\") or regex(Key.title, P.pattern, \"i\")",
    "   * Injected by dslc compiler.",
    "   */",
    "  const regex: typeof regexType;",
    "}",
    "",
    "export {};",
    "",
  ].join("\n");
}

// =====================================================
// Endpoints TypeScript Generation
// =====================================================

import type { EndpointEntry } from "./types.js";

export function generateEndpointsTs(endpoints: EndpointEntry[], registryDigest: string): string {
  const lines: string[] = [
    "// AUTO-GENERATED - DO NOT EDIT",
    "// Generated by dsl/src/codegen.ts from registry/endpoints.{dev,test,prod}.toml",
    "",
    "/**",
    " * Branded EndpointId type for type-safe endpoint references.",
    " * Use EP.redis.* or EP.http.* to get valid endpoint IDs.",
    " */",
    "export type EndpointId = string & { readonly __brand: \"EndpointId\" };",
    "",
  ];

  // Group endpoints by kind
  const byKind = new Map<string, EndpointEntry[]>();
  for (const ep of endpoints) {
    const list = byKind.get(ep.kind) || [];
    list.push(ep);
    byKind.set(ep.kind, list);
  }

  // Generate EP object
  lines.push("/**");
  lines.push(" * Endpoint registry. Use EP.<kind>.<name> to get an EndpointId.");
  lines.push(" * Example: EP.redis.default");
  lines.push(" */");
  lines.push("export const EP = {");

  // Sort kinds for deterministic output
  const sortedKinds = Array.from(byKind.keys()).sort();
  for (const kind of sortedKinds) {
    const eps = byKind.get(kind)!;
    // Sort by name within kind
    eps.sort((a, b) => a.name.localeCompare(b.name));

    lines.push(`  ${kind}: {`);
    for (const ep of eps) {
      // Convert name to valid identifier (replace non-alphanumeric with _)
      const safeName = ep.name.replace(/[^a-zA-Z0-9_]/g, "_");
      lines.push(`    /** ${ep.name} (${ep.endpoint_id}) */`);
      lines.push(`    ${safeName}: "${ep.endpoint_id}" as EndpointId,`);
    }
    lines.push(`  },`);
  }

  lines.push("} as const;");
  lines.push("");

  // Export type for each kind's endpoints
  for (const kind of sortedKinds) {
    const pascalKind = kind.charAt(0).toUpperCase() + kind.slice(1);
    lines.push(`/** Type for ${kind} endpoint IDs */`);
    lines.push(`export type ${pascalKind}EndpointId = (typeof EP.${kind})[keyof typeof EP.${kind}];`);
    lines.push("");
  }

  // Export digests and count
  lines.push("/** Env-invariant registry digest (endpoint_id, name, kind only) */");
  lines.push(`export const ENDPOINT_REGISTRY_DIGEST = "${registryDigest}";`);
  lines.push("");
  lines.push(`export const ENDPOINT_COUNT = ${endpoints.length};`);
  lines.push("");

  return lines.join("\n");
}
