// Monaco type definitions generator

import type { KeyEntry, ParamEntry, TaskRegistry, TaskEntry, EndpointEntry } from "./types.js";
import { friendlyParamName, opToMethodName, opToNamespace } from "./utils.js";

/**
 * Generate inline opts type for Monaco intellisense.
 */
function generateMonacoOptsType(task: TaskEntry): string {
  const parts: string[] = [];

  for (const param of task.params) {
    // Skip trace param (handled separately)
    if (param.name === "trace") continue;

    const tsName = friendlyParamName(param.name, param.type);
    let tsType: string;

    switch (param.type) {
      case "int":
        // Key references are KeyToken (out_key for vm, by for sort)
        tsType = (param.name === "out_key" || param.name === "by") ? "KeyToken" : "number";
        break;
      case "float":
        tsType = "number";
        break;
      case "bool":
        tsType = "boolean";
        break;
      case "string":
        tsType = "string";
        break;
      case "expr_id":
        // Accept ExprNode (builder API) or number (natural expression result)
        tsType = "ExprNode | number";
        break;
      case "pred_id":
        tsType = "PredNode";
        break;
      case "node_ref":
        tsType = "CandidateSet";
        break;
      default:
        tsType = "unknown";
    }

    if (param.nullable) {
      tsType = `${tsType} | null`;
    }

    const optional = !param.required ? "?" : "";
    parts.push(`${tsName}${optional}: ${tsType}`);
  }

  // All tasks support optional trace
  parts.push("trace?: string");

  return `{ ${parts.join("; ")} }`;
}

/**
 * Generate Monaco-compatible type definitions from registries.
 * This is a string constant that can be passed to Monaco's addExtraLib().
 */
export function generateMonacoTypes(
  keys: KeyEntry[],
  params: ParamEntry[],
  tasks: TaskRegistry,
  endpoints: EndpointEntry[]
): string {
  const lines: string[] = [
    "// AUTO-GENERATED from registries - DO NOT EDIT",
    "// Generated by dsl/src/codegen.ts from registry/*.toml",
    "// Regenerate with: pnpm -C dsl run gen",
    "",
    "/**",
    " * Monaco-compatible type definitions for the Ranking DSL.",
    " * Use with monaco.languages.typescript.typescriptDefaults.addExtraLib()",
    " */",
    "export const DSL_TYPES = `",
    "declare module '@ranking-dsl/runtime' {",
    "  // =====================================================",
    "  // Token types",
    "  // =====================================================",
    "",
    "  export interface KeyToken {",
    "    readonly kind: 'Key';",
    "    readonly id: number;",
    "    readonly name: string;",
    "    // Natural expression support: Key.x * 10, Key.x + Key.y",
    "    // These are compile-time only - the compiler extracts them via AST",
    "    valueOf(): number;",
    "  }",
    "",
    "  export interface ParamToken {",
    "    readonly kind: 'Param';",
    "    readonly id: number;",
    "    readonly name: string;",
    "    // Natural expression support: P.weight * 0.5",
    "    valueOf(): number;",
    "  }",
    "",
    "  /**",
    "   * Branded EndpointId type for type-safe endpoint references.",
    "   * Use EP.redis.* or EP.http.* to get valid endpoint IDs.",
    "   */",
    "  export type EndpointId = string & { readonly __brand: 'EndpointId' };",
    "",
    "  // =====================================================",
    "  // Expression types",
    "  // =====================================================",
    "",
    "  export type ExprNode =",
    "    | { op: 'const_number'; value: number }",
    "    | { op: 'const_null' }",
    "    | { op: 'key_ref'; key_id: number }",
    "    | { op: 'param_ref'; param_id: number }",
    "    | { op: 'add'; a: ExprNode; b: ExprNode }",
    "    | { op: 'sub'; a: ExprNode; b: ExprNode }",
    "    | { op: 'mul'; a: ExprNode; b: ExprNode }",
    "    | { op: 'neg'; x: ExprNode }",
    "    | { op: 'coalesce'; a: ExprNode; b: ExprNode };",
    "",
    "  // =====================================================",
    "  // Predicate types",
    "  // =====================================================",
    "",
    "  export type PredNode =",
    "    | { op: 'const_bool'; value: boolean }",
    "    | { op: 'and'; a: PredNode; b: PredNode }",
    "    | { op: 'or'; a: PredNode; b: PredNode }",
    "    | { op: 'not'; x: PredNode }",
    "    | { op: 'cmp'; cmp: '==' | '!=' | '<' | '<=' | '>' | '>='; a: ExprNode; b: ExprNode }",
    "    | { op: 'in'; lhs: ExprNode; list: (number | string)[] }",
    "    | { op: 'is_null'; x: ExprNode }",
    "    | { op: 'not_null'; x: ExprNode }",
    "    | { op: 'regex'; key_id: number; pattern: { kind: 'literal'; value: string } | { kind: 'param'; param_id: number }; flags: string };",
    "",
    "  // =====================================================",
    "  // Expression builder (E)",
    "  // =====================================================",
    "",
    "  export const E: {",
    "    const(value: number): ExprNode;",
    "    constNull(): ExprNode;",
    "    key(token: KeyToken): ExprNode;",
    "    param(token: ParamToken): ExprNode;",
    "    add(a: ExprNode, b: ExprNode): ExprNode;",
    "    sub(a: ExprNode, b: ExprNode): ExprNode;",
    "    mul(a: ExprNode, b: ExprNode): ExprNode;",
    "    neg(a: ExprNode): ExprNode;",
    "    coalesce(a: ExprNode, b: ExprNode): ExprNode;",
    "  };",
    "",
    "  // =====================================================",
    "  // Predicate builder (Pred)",
    "  // =====================================================",
    "",
    "  export const Pred: {",
    "    constBool(value: boolean): PredNode;",
    "    and(a: PredNode, b: PredNode): PredNode;",
    "    or(a: PredNode, b: PredNode): PredNode;",
    "    not(x: PredNode): PredNode;",
    "    cmp(op: '==' | '!=' | '<' | '<=' | '>' | '>=', a: ExprNode, b: ExprNode): PredNode;",
    "    in(lhs: ExprNode, list: (number | string)[]): PredNode;",
    "    isNull(a: ExprNode): PredNode;",
    "    notNull(a: ExprNode): PredNode;",
    "    regex(key: KeyToken, pattern: string | ParamToken, flags?: '' | 'i'): PredNode;",
    "  };",
    "",
    "  // =====================================================",
    "  // Plan context and CandidateSet",
    "  // =====================================================",
    "",
  ];

  // Source tasks have no inputs (viewer, fixedSource)
  // Source tasks: viewer (core), fixedSource (test)
  const SOURCE_TASK_METHODS = new Set(["viewer", "fixedSource"]);
  const sourceTasks = tasks.tasks.filter(t => SOURCE_TASK_METHODS.has(opToMethodName(t.op)));
  const transformTasks = tasks.tasks.filter(t => !SOURCE_TASK_METHODS.has(opToMethodName(t.op)));

  // Group source tasks by namespace
  const coreSourceTasks: TaskEntry[] = [];
  const sourceTasksByNamespace = new Map<string, TaskEntry[]>();

  for (const task of sourceTasks) {
    const ns = opToNamespace(task.op);
    if (ns === "core" || ns === undefined) {
      coreSourceTasks.push(task);
    } else {
      const list = sourceTasksByNamespace.get(ns) || [];
      list.push(task);
      sourceTasksByNamespace.set(ns, list);
    }
  }

  // Group transform tasks by namespace
  const coreTransformTasks: TaskEntry[] = [];
  const transformTasksByNamespace = new Map<string, TaskEntry[]>();

  for (const task of transformTasks) {
    const ns = opToNamespace(task.op);
    if (ns === "core" || ns === undefined) {
      coreTransformTasks.push(task);
    } else {
      const list = transformTasksByNamespace.get(ns) || [];
      list.push(task);
      transformTasksByNamespace.set(ns, list);
    }
  }

  // Generate namespace interfaces for non-core source tasks (PlanCtx namespaces)
  for (const [ns, nsTasks] of Array.from(sourceTasksByNamespace.entries()).sort((a, b) => a[0].localeCompare(b[0]))) {
    const pascalNs = ns.charAt(0).toUpperCase() + ns.slice(1);
    lines.push(`  export interface ${pascalNs}SourceTasks {`);
    for (const task of nsTasks) {
      const methodName = opToMethodName(task.op);
      const optsType = generateMonacoOptsType(task);
      lines.push(`    ${methodName}(opts: ${optsType}): CandidateSet;`);
    }
    lines.push("  }");
    lines.push("");
  }

  // Generate namespace interfaces for non-core transform tasks (CandidateSet namespaces)
  for (const [ns, nsTasks] of Array.from(transformTasksByNamespace.entries()).sort((a, b) => a[0].localeCompare(b[0]))) {
    const pascalNs = ns.charAt(0).toUpperCase() + ns.slice(1);
    lines.push(`  export interface ${pascalNs}Tasks {`);
    for (const task of nsTasks) {
      const methodName = opToMethodName(task.op);
      const optsType = generateMonacoOptsType(task);
      lines.push(`    ${methodName}(opts: ${optsType}): CandidateSet;`);
    }
    lines.push("  }");
    lines.push("");
  }

  // Generate PlanCtx interface with core source tasks at root level
  // and namespace objects for non-core source tasks
  lines.push("  export interface PlanCtx {");
  // Core source tasks at root level
  for (const task of coreSourceTasks) {
    const methodName = opToMethodName(task.op);
    const optsType = generateMonacoOptsType(task);
    lines.push(`    ${methodName}(opts: ${optsType}): CandidateSet;`);
  }
  // Namespace objects for non-core source tasks
  for (const ns of Array.from(sourceTasksByNamespace.keys()).sort()) {
    const pascalNs = ns.charAt(0).toUpperCase() + ns.slice(1);
    lines.push(`    ${ns}: ${pascalNs}SourceTasks;`);
  }
  lines.push("    requireCapability(capId: string, payload?: unknown): void;");
  lines.push("  }");
  lines.push("");

  // Generate CandidateSet interface with core transform task methods at root level
  // and namespace objects for non-core tasks
  lines.push("  export interface CandidateSet {");
  // Core tasks at root level
  for (const task of coreTransformTasks) {
    const methodName = opToMethodName(task.op);
    const optsType = generateMonacoOptsType(task);
    lines.push(`    ${methodName}(opts: ${optsType}): CandidateSet;`);
  }
  // Namespace objects for non-core tasks
  for (const ns of Array.from(transformTasksByNamespace.keys()).sort()) {
    const pascalNs = ns.charAt(0).toUpperCase() + ns.slice(1);
    lines.push(`    ${ns}: ${pascalNs}Tasks;`);
  }
  lines.push("  }");
  lines.push("");

  // Plan config and definePlan
  lines.push("  export interface PlanConfig {");
  lines.push("    name: string;");
  lines.push("    build: (ctx: PlanCtx) => CandidateSet;");
  lines.push("  }");
  lines.push("");
  lines.push("  export function definePlan(config: PlanConfig): void;");
  lines.push("");
  lines.push("  /**");
  lines.push("   * Coalesce function for null handling in natural expressions.");
  lines.push("   * Usage: Key.score * coalesce(P.weight, 0.2)");
  lines.push("   * Extracted by the compiler at compile-time.");
  lines.push("   */");
  lines.push("  export function coalesce(a: KeyToken | ParamToken | number | null, b: KeyToken | ParamToken | number): number;");
  lines.push("");

  // Generate Key object with all keys
  lines.push("  // =====================================================");
  lines.push("  // Key registry (generated from keys.toml)");
  lines.push("  // =====================================================");
  lines.push("");
  lines.push("  export const Key: {");
  for (const k of keys) {
    lines.push(`    readonly ${k.name}: KeyToken;`);
  }
  lines.push("  };");
  lines.push("");

  // Generate P object with all params
  lines.push("  // =====================================================");
  lines.push("  // Param registry (generated from params.toml)");
  lines.push("  // =====================================================");
  lines.push("");
  lines.push("  export const P: {");
  for (const p of params) {
    lines.push(`    readonly ${p.name}: ParamToken;`);
  }
  lines.push("  };");
  lines.push("");

  // Generate EP object with endpoints grouped by kind
  const byKind = new Map<string, EndpointEntry[]>();
  for (const ep of endpoints) {
    const list = byKind.get(ep.kind) ?? [];
    list.push(ep);
    byKind.set(ep.kind, list);
  }

  lines.push("  // =====================================================");
  lines.push("  // Endpoint registry (generated from endpoints.*.toml)");
  lines.push("  // =====================================================");
  lines.push("");
  lines.push("  export const EP: {");
  for (const [kind, eps] of Array.from(byKind.entries()).sort((a, b) => a[0].localeCompare(b[0]))) {
    lines.push(`    readonly ${kind}: {`);
    for (const ep of eps) {
      lines.push(`      readonly ${ep.name}: EndpointId;`);
    }
    lines.push("    };");
  }
  lines.push("  };");
  lines.push("}");
  lines.push("");

  // =========================================================
  // Global declarations for Key, P, coalesce, regex
  // These are injected by the compiler and used without imports
  // =========================================================
  lines.push("// =====================================================");
  lines.push("// Global declarations (injected by compiler)");
  lines.push("// =====================================================");
  lines.push("");
  // Note: We reference types using import() syntax since this is an ambient context
  lines.push("type _KeyToken = import('@ranking-dsl/runtime').KeyToken;");
  lines.push("type _ParamToken = import('@ranking-dsl/runtime').ParamToken;");
  lines.push("type _PredNode = import('@ranking-dsl/runtime').PredNode;");
  lines.push("type _EndpointId = import('@ranking-dsl/runtime').EndpointId;");
  lines.push("");

  // Global Key object
  lines.push("declare const Key: {");
  for (const k of keys) {
    lines.push(`  readonly ${k.name}: _KeyToken;`);
  }
  lines.push("};");
  lines.push("");

  // Global P object
  lines.push("declare const P: {");
  for (const p of params) {
    lines.push(`  readonly ${p.name}: _ParamToken;`);
  }
  lines.push("};");
  lines.push("");

  // Global EP object
  lines.push("declare const EP: {");
  for (const [kind, eps] of Array.from(byKind.entries()).sort((a, b) => a[0].localeCompare(b[0]))) {
    lines.push(`  readonly ${kind}: {`);
    for (const ep of eps) {
      lines.push(`    readonly ${ep.name}: _EndpointId;`);
    }
    lines.push("  };");
  }
  lines.push("};");
  lines.push("");

  // Global coalesce function
  lines.push("declare function coalesce(a: _KeyToken | _ParamToken | number | null, b: _KeyToken | _ParamToken | number): number;");
  lines.push("");

  // Global regex function for predicates
  lines.push("declare function regex(key: _KeyToken, pattern: string | _ParamToken, flags?: '' | 'i'): _PredNode;");
  lines.push("`;");
  lines.push("");

  return lines.join("\n");
}
