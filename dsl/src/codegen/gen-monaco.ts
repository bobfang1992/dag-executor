// Monaco type definitions generator

import type { KeyEntry, ParamEntry, TaskRegistry, TaskEntry } from "./types.js";
import { friendlyParamName } from "./utils.js";

/**
 * Generate inline opts type for Monaco intellisense.
 */
function generateMonacoOptsType(task: TaskEntry): string {
  const parts: string[] = [];

  for (const param of task.params) {
    // Skip trace param (handled separately)
    if (param.name === "trace") continue;

    const tsName = friendlyParamName(param.name, param.type);
    let tsType: string;

    switch (param.type) {
      case "int":
        tsType = param.name === "out_key" ? "KeyToken" : "number";
        break;
      case "float":
        tsType = "number";
        break;
      case "bool":
        tsType = "boolean";
        break;
      case "string":
        tsType = "string";
        break;
      case "expr_id":
        // Accept ExprNode (builder API) or number (natural expression result)
        tsType = "ExprNode | number";
        break;
      case "pred_id":
        tsType = "PredNode";
        break;
      case "node_ref":
        tsType = "CandidateSet";
        break;
      default:
        tsType = "unknown";
    }

    if (param.nullable) {
      tsType = `${tsType} | null`;
    }

    const optional = !param.required ? "?" : "";
    parts.push(`${tsName}${optional}: ${tsType}`);
  }

  // All tasks support optional trace
  parts.push("trace?: string");

  return `{ ${parts.join("; ")} }`;
}

/**
 * Generate Monaco-compatible type definitions from registries.
 * This is a string constant that can be passed to Monaco's addExtraLib().
 */
export function generateMonacoTypes(
  keys: KeyEntry[],
  params: ParamEntry[],
  tasks: TaskRegistry
): string {
  const lines: string[] = [
    "// AUTO-GENERATED from registries - DO NOT EDIT",
    "// Generated by dsl/src/codegen.ts from registry/*.toml",
    "// Regenerate with: pnpm -C dsl run gen",
    "",
    "/**",
    " * Monaco-compatible type definitions for the Ranking DSL.",
    " * Use with monaco.languages.typescript.typescriptDefaults.addExtraLib()",
    " */",
    "export const DSL_TYPES = `",
    "declare module '@ranking-dsl/runtime' {",
    "  // =====================================================",
    "  // Token types",
    "  // =====================================================",
    "",
    "  export interface KeyToken {",
    "    readonly kind: 'Key';",
    "    readonly id: number;",
    "    readonly name: string;",
    "    // Natural expression support: Key.x * 10, Key.x + Key.y",
    "    // These are compile-time only - the compiler extracts them via AST",
    "    valueOf(): number;",
    "  }",
    "",
    "  export interface ParamToken {",
    "    readonly kind: 'Param';",
    "    readonly id: number;",
    "    readonly name: string;",
    "    // Natural expression support: P.weight * 0.5",
    "    valueOf(): number;",
    "  }",
    "",
    "  // =====================================================",
    "  // Expression types",
    "  // =====================================================",
    "",
    "  export type ExprNode =",
    "    | { op: 'const_number'; value: number }",
    "    | { op: 'const_null' }",
    "    | { op: 'key_ref'; key_id: number }",
    "    | { op: 'param_ref'; param_id: number }",
    "    | { op: 'add'; a: ExprNode; b: ExprNode }",
    "    | { op: 'sub'; a: ExprNode; b: ExprNode }",
    "    | { op: 'mul'; a: ExprNode; b: ExprNode }",
    "    | { op: 'neg'; x: ExprNode }",
    "    | { op: 'coalesce'; a: ExprNode; b: ExprNode };",
    "",
    "  // =====================================================",
    "  // Predicate types",
    "  // =====================================================",
    "",
    "  export type PredNode =",
    "    | { op: 'const_bool'; value: boolean }",
    "    | { op: 'and'; a: PredNode; b: PredNode }",
    "    | { op: 'or'; a: PredNode; b: PredNode }",
    "    | { op: 'not'; x: PredNode }",
    "    | { op: 'cmp'; cmp: '==' | '!=' | '<' | '<=' | '>' | '>='; a: ExprNode; b: ExprNode }",
    "    | { op: 'in'; lhs: ExprNode; list: (number | string)[] }",
    "    | { op: 'is_null'; x: ExprNode }",
    "    | { op: 'not_null'; x: ExprNode }",
    "    | { op: 'regex'; key_id: number; pattern: { kind: 'literal'; value: string } | { kind: 'param'; param_id: number }; flags: string };",
    "",
    "  // =====================================================",
    "  // Expression builder (E)",
    "  // =====================================================",
    "",
    "  export const E: {",
    "    const(value: number): ExprNode;",
    "    constNull(): ExprNode;",
    "    key(token: KeyToken): ExprNode;",
    "    param(token: ParamToken): ExprNode;",
    "    add(a: ExprNode, b: ExprNode): ExprNode;",
    "    sub(a: ExprNode, b: ExprNode): ExprNode;",
    "    mul(a: ExprNode, b: ExprNode): ExprNode;",
    "    neg(a: ExprNode): ExprNode;",
    "    coalesce(a: ExprNode, b: ExprNode): ExprNode;",
    "  };",
    "",
    "  // =====================================================",
    "  // Predicate builder (Pred)",
    "  // =====================================================",
    "",
    "  export const Pred: {",
    "    constBool(value: boolean): PredNode;",
    "    and(a: PredNode, b: PredNode): PredNode;",
    "    or(a: PredNode, b: PredNode): PredNode;",
    "    not(x: PredNode): PredNode;",
    "    cmp(op: '==' | '!=' | '<' | '<=' | '>' | '>=', a: ExprNode, b: ExprNode): PredNode;",
    "    in(lhs: ExprNode, list: (number | string)[]): PredNode;",
    "    isNull(a: ExprNode): PredNode;",
    "    notNull(a: ExprNode): PredNode;",
    "    regex(key: KeyToken, pattern: string | ParamToken, flags?: '' | 'i'): PredNode;",
    "  };",
    "",
    "  // =====================================================",
    "  // Plan context and CandidateSet",
    "  // =====================================================",
    "",
  ];

  // Generate source task methods for PlanCtx.viewer
  const sourceTasks = tasks.tasks.filter(t => t.op.startsWith("viewer."));
  const transformTasks = tasks.tasks.filter(t => !t.op.startsWith("viewer."));

  lines.push("  export interface PlanCtx {");
  lines.push("    viewer: {");
  for (const task of sourceTasks) {
    const methodName = task.op.replace("viewer.", "");
    const optsType = generateMonacoOptsType(task);
    lines.push(`      ${methodName}(opts: ${optsType}): CandidateSet;`);
  }
  lines.push("    };");
  lines.push("    requireCapability(capId: string, payload?: unknown): void;");
  lines.push("  }");
  lines.push("");

  // Generate CandidateSet interface with transform task methods
  lines.push("  export interface CandidateSet {");
  for (const task of transformTasks) {
    const optsType = generateMonacoOptsType(task);
    lines.push(`    ${task.op}(opts: ${optsType}): CandidateSet;`);
  }
  lines.push("  }");
  lines.push("");

  // Plan config and definePlan
  lines.push("  export interface PlanConfig {");
  lines.push("    name: string;");
  lines.push("    build: (ctx: PlanCtx) => CandidateSet;");
  lines.push("  }");
  lines.push("");
  lines.push("  export function definePlan(config: PlanConfig): void;");
  lines.push("");
  lines.push("  /**");
  lines.push("   * Coalesce function for null handling in natural expressions.");
  lines.push("   * Usage: Key.score * coalesce(P.weight, 0.2)");
  lines.push("   * Extracted by the compiler at compile-time.");
  lines.push("   */");
  lines.push("  export function coalesce(a: KeyToken | ParamToken | number | null, b: KeyToken | ParamToken | number): number;");
  lines.push("");

  // Generate Key object with all keys
  lines.push("  // =====================================================");
  lines.push("  // Key registry (generated from keys.toml)");
  lines.push("  // =====================================================");
  lines.push("");
  lines.push("  export const Key: {");
  for (const k of keys) {
    lines.push(`    readonly ${k.name}: KeyToken;`);
  }
  lines.push("  };");
  lines.push("");

  // Generate P object with all params
  lines.push("  // =====================================================");
  lines.push("  // Param registry (generated from params.toml)");
  lines.push("  // =====================================================");
  lines.push("");
  lines.push("  export const P: {");
  for (const p of params) {
    lines.push(`    readonly ${p.name}: ParamToken;`);
  }
  lines.push("  };");
  lines.push("}");
  lines.push("`;");
  lines.push("");

  return lines.join("\n");
}
