// AUTO-GENERATED - DO NOT EDIT
// Generated by dsl/src/codegen.ts from registry/capabilities.toml

export type CapabilityStatus = "implemented" | "draft" | "deprecated" | "blocked";

// JSON Schema subset for capability payload validation
export interface JsonSchema {
  type?: string;
  properties?: Record<string, JsonSchema>;
  additionalProperties?: boolean;
  required?: string[];
}

export interface CapabilityMeta {
  id: string;
  rfc: string;
  name: string;
  status: CapabilityStatus;
  doc: string;
  payloadSchema: JsonSchema | null;
}

export const CAPABILITY_REGISTRY: Record<string, CapabilityMeta> = {
  "cap.rfc.0001.extensions_capabilities.v1": {
    id: "cap.rfc.0001.extensions_capabilities.v1",
    rfc: "0001",
    name: "extensions_capabilities",
    status: "implemented",
    doc: "Base extensions/capabilities mechanism for IR evolution",
    payloadSchema: {"type":"object","additionalProperties":false},
  },
  "cap.rfc.0005.key_effects_writes_exact.v1": {
    id: "cap.rfc.0005.key_effects_writes_exact.v1",
    rfc: "0005",
    name: "key_effects_writes_exact",
    status: "draft",
    doc: "Strict shape enforcement for branching meta-tasks (RFC0005)",
    payloadSchema: {"type":"object","additionalProperties":false},
  },
};

export const SUPPORTED_CAPABILITIES = new Set(
  Object.entries(CAPABILITY_REGISTRY)
    .filter(([, meta]) => meta.status === "implemented" || meta.status === "deprecated")
    .map(([id]) => id)
);

export const CAPABILITY_REGISTRY_DIGEST = "3537d0e4f5fe759dd852f53a81972534f50d14cb6e6a7772b5bf12cadb81d4c8";
export const CAPABILITY_COUNT = 2;

// ============================================================
// Simple JSON Schema validator (subset for capability payloads)
// ============================================================

export function validatePayload(capId: string, payload: unknown): void {
  const meta = CAPABILITY_REGISTRY[capId];
  if (!meta) return; // Unknown cap handled elsewhere

  const schema = meta.payloadSchema;

  // No schema = no payload allowed
  if (schema === null) {
    if (payload !== undefined && payload !== null) {
      throw new Error(`capability '${capId}': no payload allowed`);
    }
    return;
  }

  // Undefined payload is OK (key omitted), but null is invalid for object schemas
  if (payload === undefined) return;
  if (payload === null) {
    throw new Error(`capability '${capId}': payload is null, expected object (use {} or omit key)`);
  }

  if (schema.type === "object") {
    if (typeof payload !== "object" || payload === null || Array.isArray(payload)) {
      throw new Error(`capability '${capId}': payload must be object`);
    }
    const obj = payload as Record<string, unknown>;
    if (schema.additionalProperties === false) {
      const allowed = new Set(Object.keys(schema.properties ?? {}));
      for (const key of Object.keys(obj)) {
        if (!allowed.has(key)) {
          throw new Error(`capability '${capId}': unexpected key '${key}'`);
        }
      }
    }
    // Check required properties
    for (const req of schema.required ?? []) {
      if (!(req in obj)) {
        throw new Error(`capability '${capId}': missing required '${req}'`);
      }
    }
    // Type-check properties
    for (const [key, propSchema] of Object.entries(schema.properties ?? {})) {
      if (key in obj) {
        validatePropertyType(capId, key, obj[key], propSchema);
      }
    }
  }
}

function validatePropertyType(
  capId: string,
  key: string,
  value: unknown,
  schema: JsonSchema
): void {
  if (schema.type === "boolean" && typeof value !== "boolean") {
    throw new Error(`capability '${capId}': '${key}' must be boolean`);
  }
  if (schema.type === "string" && typeof value !== "string") {
    throw new Error(`capability '${capId}': '${key}' must be string`);
  }
  if (schema.type === "number" && typeof value !== "number") {
    throw new Error(`capability '${capId}': '${key}' must be number`);
  }
  if (schema.type === "array" && !Array.isArray(value)) {
    throw new Error(`capability '${capId}': '${key}' must be array`);
  }
  if (schema.type === "object" && (typeof value !== "object" || value === null || Array.isArray(value))) {
    throw new Error(`capability '${capId}': '${key}' must be object`);
  }
}
