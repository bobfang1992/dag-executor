/**
 * Monaco-compatible type definitions for the Ranking DSL.
 * Use with monaco.languages.typescript.typescriptDefaults.addExtraLib()
 */
export declare const DSL_TYPES = "\ndeclare module '@ranking-dsl/runtime' {\n  // =====================================================\n  // Token types\n  // =====================================================\n\n  export interface KeyToken {\n    readonly kind: 'Key';\n    readonly id: number;\n    readonly name: string;\n    // Natural expression support: Key.x * 10, Key.x + Key.y\n    // These are compile-time only - the compiler extracts them via AST\n    valueOf(): number;\n  }\n\n  export interface ParamToken {\n    readonly kind: 'Param';\n    readonly id: number;\n    readonly name: string;\n    // Natural expression support: P.weight * 0.5\n    valueOf(): number;\n  }\n\n  // =====================================================\n  // Expression types\n  // =====================================================\n\n  export type ExprNode =\n    | { op: 'const_number'; value: number }\n    | { op: 'const_null' }\n    | { op: 'key_ref'; key_id: number }\n    | { op: 'param_ref'; param_id: number }\n    | { op: 'add'; a: ExprNode; b: ExprNode }\n    | { op: 'sub'; a: ExprNode; b: ExprNode }\n    | { op: 'mul'; a: ExprNode; b: ExprNode }\n    | { op: 'neg'; x: ExprNode }\n    | { op: 'coalesce'; a: ExprNode; b: ExprNode };\n\n  // =====================================================\n  // Predicate types\n  // =====================================================\n\n  export type PredNode =\n    | { op: 'const_bool'; value: boolean }\n    | { op: 'and'; a: PredNode; b: PredNode }\n    | { op: 'or'; a: PredNode; b: PredNode }\n    | { op: 'not'; x: PredNode }\n    | { op: 'cmp'; cmp: '==' | '!=' | '<' | '<=' | '>' | '>='; a: ExprNode; b: ExprNode }\n    | { op: 'in'; lhs: ExprNode; list: (number | string)[] }\n    | { op: 'is_null'; x: ExprNode }\n    | { op: 'not_null'; x: ExprNode }\n    | { op: 'regex'; key_id: number; pattern: { kind: 'literal'; value: string } | { kind: 'param'; param_id: number }; flags: string };\n\n  // =====================================================\n  // Expression builder (E)\n  // =====================================================\n\n  export const E: {\n    const(value: number): ExprNode;\n    constNull(): ExprNode;\n    key(token: KeyToken): ExprNode;\n    param(token: ParamToken): ExprNode;\n    add(a: ExprNode, b: ExprNode): ExprNode;\n    sub(a: ExprNode, b: ExprNode): ExprNode;\n    mul(a: ExprNode, b: ExprNode): ExprNode;\n    neg(a: ExprNode): ExprNode;\n    coalesce(a: ExprNode, b: ExprNode): ExprNode;\n  };\n\n  // =====================================================\n  // Predicate builder (Pred)\n  // =====================================================\n\n  export const Pred: {\n    constBool(value: boolean): PredNode;\n    and(a: PredNode, b: PredNode): PredNode;\n    or(a: PredNode, b: PredNode): PredNode;\n    not(x: PredNode): PredNode;\n    cmp(op: '==' | '!=' | '<' | '<=' | '>' | '>=', a: ExprNode, b: ExprNode): PredNode;\n    in(lhs: ExprNode, list: (number | string)[]): PredNode;\n    isNull(a: ExprNode): PredNode;\n    notNull(a: ExprNode): PredNode;\n    regex(key: KeyToken, pattern: string | ParamToken, flags?: '' | 'i'): PredNode;\n  };\n\n  // =====================================================\n  // Plan context and CandidateSet\n  // =====================================================\n\n  export interface PlanCtx {\n    viewer: {\n      fetch_cached_recommendation(opts: { fanout: number; trace?: string }): CandidateSet;\n      follow(opts: { fanout: number; trace?: string }): CandidateSet;\n    };\n    requireCapability(capId: string, payload?: unknown): void;\n  }\n\n  export interface CandidateSet {\n    concat(other: CandidateSet, opts?: { trace?: string }): CandidateSet;\n    filter(opts: { pred: PredNode; trace?: string }): CandidateSet;\n    sort(opts: { by: number; order?: string; trace?: string }): CandidateSet;\n    take(opts: { count: number; trace?: string }): CandidateSet;\n    vm(opts: { expr: ExprNode | number; outKey: KeyToken; trace?: string }): CandidateSet;\n  }\n\n  export interface PlanConfig {\n    name: string;\n    build: (ctx: PlanCtx) => CandidateSet;\n  }\n\n  export function definePlan(config: PlanConfig): void;\n\n  /**\n   * Coalesce function for null handling in natural expressions.\n   * Usage: Key.score * coalesce(P.weight, 0.2)\n   * Extracted by the compiler at compile-time.\n   */\n  export function coalesce(a: KeyToken | ParamToken | number | null, b: KeyToken | ParamToken | number): number;\n\n  // =====================================================\n  // Key registry (generated from keys.toml)\n  // =====================================================\n\n  export const Key: {\n    readonly id: KeyToken;\n    readonly model_score_1: KeyToken;\n    readonly model_score_2: KeyToken;\n    readonly final_score: KeyToken;\n    readonly country: KeyToken;\n    readonly title: KeyToken;\n    readonly features_esr: KeyToken;\n    readonly features_lsr: KeyToken;\n  };\n\n  // =====================================================\n  // Param registry (generated from params.toml)\n  // =====================================================\n\n  export const P: {\n    readonly media_age_penalty_weight: ParamToken;\n    readonly blocklist_regex: ParamToken;\n    readonly esr_cutoff: ParamToken;\n  };\n}\n";
//# sourceMappingURL=monaco-types.d.ts.map