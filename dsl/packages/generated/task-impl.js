// AUTO-GENERATED from C++ TaskSpec - DO NOT EDIT
// Generated by dsl/src/codegen.ts from registry/tasks.toml
// Regenerate with: pnpm -C dsl run gen
// =====================================================
// Types for plan context interface
// =====================================================
/** Interface for expression placeholder detection */
export function isExprPlaceholder(value) {
    return (value !== null &&
        typeof value === "object" &&
        "__expr_id" in value &&
        typeof value.__expr_id === "number");
}
/** Interface for predicate placeholder detection */
export function isPredPlaceholder(value) {
    return (value !== null &&
        typeof value === "object" &&
        "__pred_id" in value &&
        typeof value.__pred_id === "number");
}
// =====================================================
// Validation helpers
// =====================================================
function assertNotUndefined(value, name) {
    if (value === undefined)
        throw new Error(`${name} is undefined`);
}
function assertInteger(value, name) {
    if (typeof value !== "number" || !Number.isInteger(value)) {
        throw new Error(`${name} must be an integer, got ${typeof value === "number" ? value : typeof value}`);
    }
}
function assertKeyToken(value, name) {
    if (value === null || typeof value !== "object") {
        throw new Error(`${name} must be a KeyToken, got ${value === null ? "null" : typeof value}`);
    }
    const token = value;
    if (typeof token.id !== "number" || !Number.isInteger(token.id)) {
        throw new Error(`${name}.id must be an integer, got ${typeof token.id === "number" ? token.id : typeof token.id}`);
    }
}
function assertStringOrNull(value, name) {
    if (value !== null && typeof value !== "string") {
        throw new Error(`${name} must be a string or null, got ${typeof value}`);
    }
}
function assertExprInput(value, name) {
    if (value === null || typeof value !== "object") {
        throw new Error(`${name} must be an ExprNode or ExprPlaceholder, got ${value === null ? "null" : typeof value}`);
    }
    const obj = value;
    // ExprPlaceholder has __expr_id, ExprNode has op
    if (typeof obj.__expr_id !== "number" && typeof obj.op !== "string") {
        throw new Error(`${name} must be an ExprNode (with 'op') or ExprPlaceholder (with '__expr_id')`);
    }
}
function assertPredInput(value, name) {
    if (value === null || typeof value !== "object") {
        throw new Error(`${name} must be a PredNode or PredPlaceholder, got ${value === null ? "null" : typeof value}`);
    }
    const obj = value;
    // PredPlaceholder has __pred_id, PredNode has op
    if (typeof obj.__pred_id !== "number" && typeof obj.op !== "string") {
        throw new Error(`${name} must be a PredNode (with 'op') or PredPlaceholder (with '__pred_id')`);
    }
}
function assertCandidateSet(value, name) {
    if (value === null || typeof value !== "object") {
        throw new Error(`${name} must be a CandidateSet, got ${value === null ? "null" : typeof value}`);
    }
    const obj = value;
    if (typeof obj.getNodeId !== "function") {
        throw new Error(`${name} must be a CandidateSet with 'getNodeId' method`);
    }
}
function checkNoUndefined(obj, context) {
    for (const [key, value] of Object.entries(obj)) {
        if (value === undefined) {
            throw new Error(`${context}.${key} is undefined`);
        }
        // Recursively check nested objects (but not arrays)
        if (typeof value === "object" && value !== null && !Array.isArray(value)) {
            checkNoUndefined(value, `${context}.${key}`);
        }
    }
}
// =====================================================
// Transform task implementations (for CandidateSet methods)
// =====================================================
/** Implementation for concat */
export function concatImpl(ctx, inputNodeId, opts) {
    assertNotUndefined(opts, "concat(opts)");
    assertNotUndefined(opts.rhs, "concat({ rhs })");
    assertCandidateSet(opts.rhs, "concat({ rhs })");
    const { extensions, ...rest } = opts;
    checkNoUndefined(rest, "concat(opts)");
    // Validate trace
    if (opts.trace !== undefined) {
        assertStringOrNull(opts.trace, "concat({ trace })");
    }
    const params = {
        rhs: opts.rhs.getNodeId(),
        trace: opts.trace ?? null,
    };
    return ctx.addNode("concat", [inputNodeId], params, extensions);
}
/** Implementation for filter */
export function filterImpl(ctx, inputNodeId, opts) {
    assertNotUndefined(opts, "filter(opts)");
    assertNotUndefined(opts.pred, "filter({ pred })");
    const { extensions, ...rest } = opts;
    checkNoUndefined(rest, "filter(opts)");
    // Validate trace
    if (opts.trace !== undefined) {
        assertStringOrNull(opts.trace, "filter({ trace })");
    }
    // Validate and handle predicate table
    assertPredInput(opts.pred, "filter({ pred })");
    let predId;
    if (isPredPlaceholder(opts.pred)) {
        // AST-extracted predicate - use special prefix for later remapping
        predId = `__static_p${opts.pred.__pred_id}`;
    }
    else {
        // Regular builder-style predicate
        predId = ctx.addPred(opts.pred);
    }
    const params = {
        pred_id: predId,
        trace: opts.trace ?? null,
    };
    return ctx.addNode("filter", [inputNodeId], params, extensions);
}
/** Implementation for follow */
export function followImpl(ctx, inputNodeId, opts) {
    assertNotUndefined(opts, "follow(opts)");
    assertNotUndefined(opts.endpoint, "follow({ endpoint })");
    assertNotUndefined(opts.fanout, "follow({ fanout })");
    assertInteger(opts.fanout, "follow({ fanout })");
    const { extensions, ...rest } = opts;
    checkNoUndefined(rest, "follow(opts)");
    // Validate trace
    if (opts.trace !== undefined) {
        assertStringOrNull(opts.trace, "follow({ trace })");
    }
    const params = {
        endpoint: opts.endpoint,
        fanout: opts.fanout,
        trace: opts.trace ?? null,
    };
    return ctx.addNode("follow", [inputNodeId], params, extensions);
}
/** Implementation for media */
export function mediaImpl(ctx, inputNodeId, opts) {
    assertNotUndefined(opts, "media(opts)");
    assertNotUndefined(opts.endpoint, "media({ endpoint })");
    assertNotUndefined(opts.fanout, "media({ fanout })");
    assertInteger(opts.fanout, "media({ fanout })");
    const { extensions, ...rest } = opts;
    checkNoUndefined(rest, "media(opts)");
    // Validate trace
    if (opts.trace !== undefined) {
        assertStringOrNull(opts.trace, "media({ trace })");
    }
    const params = {
        endpoint: opts.endpoint,
        fanout: opts.fanout,
        trace: opts.trace ?? null,
    };
    return ctx.addNode("media", [inputNodeId], params, extensions);
}
/** Implementation for recommendation */
export function recommendationImpl(ctx, inputNodeId, opts) {
    assertNotUndefined(opts, "recommendation(opts)");
    assertNotUndefined(opts.endpoint, "recommendation({ endpoint })");
    assertNotUndefined(opts.fanout, "recommendation({ fanout })");
    assertInteger(opts.fanout, "recommendation({ fanout })");
    const { extensions, ...rest } = opts;
    checkNoUndefined(rest, "recommendation(opts)");
    // Validate trace
    if (opts.trace !== undefined) {
        assertStringOrNull(opts.trace, "recommendation({ trace })");
    }
    const params = {
        endpoint: opts.endpoint,
        fanout: opts.fanout,
        trace: opts.trace ?? null,
    };
    return ctx.addNode("recommendation", [inputNodeId], params, extensions);
}
/** Implementation for sort */
export function sortImpl(ctx, inputNodeId, opts) {
    assertNotUndefined(opts, "sort(opts)");
    assertNotUndefined(opts.by, "sort({ by })");
    assertKeyToken(opts.by, "sort({ by })");
    const { extensions, ...rest } = opts;
    checkNoUndefined(rest, "sort(opts)");
    // Validate trace
    if (opts.trace !== undefined) {
        assertStringOrNull(opts.trace, "sort({ trace })");
    }
    const params = {
        by: opts.by.id,
        order: opts.order,
        trace: opts.trace ?? null,
    };
    return ctx.addNode("sort", [inputNodeId], params, extensions);
}
/** Implementation for take */
export function takeImpl(ctx, inputNodeId, opts) {
    assertNotUndefined(opts, "take(opts)");
    assertNotUndefined(opts.count, "take({ count })");
    assertInteger(opts.count, "take({ count })");
    const { extensions, ...rest } = opts;
    checkNoUndefined(rest, "take(opts)");
    // Validate trace
    if (opts.trace !== undefined) {
        assertStringOrNull(opts.trace, "take({ trace })");
    }
    const params = {
        count: opts.count,
        trace: opts.trace ?? null,
    };
    return ctx.addNode("take", [inputNodeId], params, extensions);
}
/** Implementation for viewer */
export function viewerImpl(ctx, inputNodeId, opts) {
    assertNotUndefined(opts, "viewer(opts)");
    assertNotUndefined(opts.endpoint, "viewer({ endpoint })");
    const { extensions, ...rest } = opts;
    checkNoUndefined(rest, "viewer(opts)");
    // Validate trace
    if (opts.trace !== undefined) {
        assertStringOrNull(opts.trace, "viewer({ trace })");
    }
    const params = {
        endpoint: opts.endpoint,
        trace: opts.trace ?? null,
    };
    return ctx.addNode("viewer", [inputNodeId], params, extensions);
}
/** Implementation for vm */
export function vmImpl(ctx, inputNodeId, opts) {
    assertNotUndefined(opts, "vm(opts)");
    assertNotUndefined(opts.expr, "vm({ expr })");
    assertNotUndefined(opts.outKey, "vm({ outKey })");
    assertKeyToken(opts.outKey, "vm({ outKey })");
    const { extensions, ...rest } = opts;
    checkNoUndefined(rest, "vm(opts)");
    // Validate trace
    if (opts.trace !== undefined) {
        assertStringOrNull(opts.trace, "vm({ trace })");
    }
    // Validate and handle expression table
    assertExprInput(opts.expr, "vm({ expr })");
    let exprId;
    if (isExprPlaceholder(opts.expr)) {
        // AST-extracted expression - use special prefix for later remapping
        exprId = `__static_e${opts.expr.__expr_id}`;
    }
    else {
        // Regular builder-style expression
        exprId = ctx.addExpr(opts.expr);
    }
    const params = {
        expr_id: exprId,
        out_key: opts.outKey.id,
        trace: opts.trace ?? null,
    };
    return ctx.addNode("vm", [inputNodeId], params, extensions);
}
// =====================================================
// Task metadata for runtime use
// =====================================================
export const GENERATED_TASKS = {
    source: [],
    transform: ["concat", "filter", "follow", "media", "recommendation", "sort", "take", "viewer", "vm"],
};
