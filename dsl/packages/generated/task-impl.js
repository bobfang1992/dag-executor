// AUTO-GENERATED from C++ TaskSpec - DO NOT EDIT
// Generated by dsl/src/codegen.ts from registry/tasks.toml
// Regenerate with: pnpm -C dsl run gen
// =====================================================
// Types for plan context interface
// =====================================================
/** Interface for expression placeholder detection */
export function isExprPlaceholder(value) {
    return (value !== null &&
        typeof value === "object" &&
        "__expr_id" in value &&
        typeof value.__expr_id === "number");
}
/** Interface for predicate placeholder detection */
export function isPredPlaceholder(value) {
    return (value !== null &&
        typeof value === "object" &&
        "__pred_id" in value &&
        typeof value.__pred_id === "number");
}
// =====================================================
// Validation helpers
// =====================================================
function assertNotUndefined(value, name) {
    if (value === undefined)
        throw new Error(`${name} is undefined`);
}
function assertInteger(value, name) {
    if (typeof value !== "number" || !Number.isInteger(value)) {
        throw new Error(`${name} must be an integer, got ${typeof value === "number" ? value : typeof value}`);
    }
}
function assertKeyToken(value, name) {
    if (value === null || typeof value !== "object") {
        throw new Error(`${name} must be a KeyToken, got ${value === null ? "null" : typeof value}`);
    }
    const token = value;
    if (typeof token.id !== "number" || !Number.isInteger(token.id)) {
        throw new Error(`${name}.id must be an integer, got ${typeof token.id === "number" ? token.id : typeof token.id}`);
    }
}
function assertStringOrNull(value, name) {
    if (value !== null && typeof value !== "string") {
        throw new Error(`${name} must be a string or null, got ${typeof value}`);
    }
}
function assertExprInput(value, name) {
    if (value === null || typeof value !== "object") {
        throw new Error(`${name} must be an ExprNode or ExprPlaceholder, got ${value === null ? "null" : typeof value}`);
    }
    const obj = value;
    // ExprPlaceholder has __expr_id, ExprNode has op
    if (typeof obj.__expr_id !== "number" && typeof obj.op !== "string") {
        throw new Error(`${name} must be an ExprNode (with 'op') or ExprPlaceholder (with '__expr_id')`);
    }
}
function assertPredInput(value, name) {
    if (value === null || typeof value !== "object") {
        throw new Error(`${name} must be a PredNode or PredPlaceholder, got ${value === null ? "null" : typeof value}`);
    }
    const obj = value;
    // PredPlaceholder has __pred_id, PredNode has op
    if (typeof obj.__pred_id !== "number" && typeof obj.op !== "string") {
        throw new Error(`${name} must be a PredNode (with 'op') or PredPlaceholder (with '__pred_id')`);
    }
}
function assertCandidateSet(value, name) {
    if (value === null || typeof value !== "object") {
        throw new Error(`${name} must be a CandidateSet, got ${value === null ? "null" : typeof value}`);
    }
    const obj = value;
    if (typeof obj.getNodeId !== "function") {
        throw new Error(`${name} must be a CandidateSet with 'getNodeId' method`);
    }
}
function checkNoUndefined(obj, context) {
    for (const [key, value] of Object.entries(obj)) {
        if (value === undefined) {
            throw new Error(`${context}.${key} is undefined`);
        }
        // Recursively check nested objects (but not arrays)
        if (typeof value === "object" && value !== null && !Array.isArray(value)) {
            checkNoUndefined(value, `${context}.${key}`);
        }
    }
}
function assertEndpointId(value, name) {
    if (typeof value !== "string") {
        throw new Error(`${name} must be a string (EndpointId), got ${typeof value}`);
    }
    if (!value.startsWith("ep_")) {
        throw new Error(`${name} must start with "ep_", got "${value}"`);
    }
    if (value.length > 64) {
        throw new Error(`${name} too long (max 64 chars), got ${value.length}`);
    }
}
// =====================================================
// Source task implementations (for PlanCtx.viewer)
// =====================================================
/** Implementation for core::viewer */
export function viewerImpl(ctx, opts) {
    assertNotUndefined(opts, "viewer(opts)");
    assertNotUndefined(opts.endpoint, "viewer({ endpoint })");
    assertEndpointId(opts.endpoint, "viewer({ endpoint })");
    const { extensions, ...rest } = opts;
    checkNoUndefined(rest, "viewer(opts)");
    // Validate trace
    if (opts.trace !== undefined) {
        assertStringOrNull(opts.trace, "viewer({ trace })");
    }
    const params = {
        endpoint: opts.endpoint,
        trace: opts.trace ?? null,
    };
    return ctx.addNode("core::viewer", [], params, extensions);
}
// =====================================================
// Transform task implementations (for CandidateSet methods)
// =====================================================
/** Implementation for core::concat */
export function concatImpl(ctx, inputNodeId, opts) {
    assertNotUndefined(opts, "concat(opts)");
    assertNotUndefined(opts.rhs, "concat({ rhs })");
    assertCandidateSet(opts.rhs, "concat({ rhs })");
    const { extensions, ...rest } = opts;
    checkNoUndefined(rest, "concat(opts)");
    // Validate trace
    if (opts.trace !== undefined) {
        assertStringOrNull(opts.trace, "concat({ trace })");
    }
    const params = {
        rhs: opts.rhs.getNodeId(),
        trace: opts.trace ?? null,
    };
    return ctx.addNode("core::concat", [inputNodeId], params, extensions);
}
/** Implementation for core::filter */
export function filterImpl(ctx, inputNodeId, opts) {
    assertNotUndefined(opts, "filter(opts)");
    assertNotUndefined(opts.pred, "filter({ pred })");
    const { extensions, ...rest } = opts;
    checkNoUndefined(rest, "filter(opts)");
    // Validate trace
    if (opts.trace !== undefined) {
        assertStringOrNull(opts.trace, "filter({ trace })");
    }
    // Validate and handle predicate table
    assertPredInput(opts.pred, "filter({ pred })");
    let predId;
    if (isPredPlaceholder(opts.pred)) {
        // AST-extracted predicate - use special prefix for later remapping
        predId = `__static_p${opts.pred.__pred_id}`;
    }
    else {
        // Regular builder-style predicate
        predId = ctx.addPred(opts.pred);
    }
    const params = {
        pred_id: predId,
        trace: opts.trace ?? null,
    };
    return ctx.addNode("core::filter", [inputNodeId], params, extensions);
}
/** Implementation for core::follow */
export function followImpl(ctx, inputNodeId, opts) {
    assertNotUndefined(opts, "follow(opts)");
    assertNotUndefined(opts.endpoint, "follow({ endpoint })");
    assertEndpointId(opts.endpoint, "follow({ endpoint })");
    assertNotUndefined(opts.fanout, "follow({ fanout })");
    assertInteger(opts.fanout, "follow({ fanout })");
    const { extensions, ...rest } = opts;
    checkNoUndefined(rest, "follow(opts)");
    // Validate trace
    if (opts.trace !== undefined) {
        assertStringOrNull(opts.trace, "follow({ trace })");
    }
    const params = {
        endpoint: opts.endpoint,
        fanout: opts.fanout,
        trace: opts.trace ?? null,
    };
    return ctx.addNode("core::follow", [inputNodeId], params, extensions);
}
/** Implementation for core::media */
export function mediaImpl(ctx, inputNodeId, opts) {
    assertNotUndefined(opts, "media(opts)");
    assertNotUndefined(opts.endpoint, "media({ endpoint })");
    assertEndpointId(opts.endpoint, "media({ endpoint })");
    assertNotUndefined(opts.fanout, "media({ fanout })");
    assertInteger(opts.fanout, "media({ fanout })");
    const { extensions, ...rest } = opts;
    checkNoUndefined(rest, "media(opts)");
    // Validate trace
    if (opts.trace !== undefined) {
        assertStringOrNull(opts.trace, "media({ trace })");
    }
    const params = {
        endpoint: opts.endpoint,
        fanout: opts.fanout,
        trace: opts.trace ?? null,
    };
    return ctx.addNode("core::media", [inputNodeId], params, extensions);
}
/** Implementation for core::recommendation */
export function recommendationImpl(ctx, inputNodeId, opts) {
    assertNotUndefined(opts, "recommendation(opts)");
    assertNotUndefined(opts.endpoint, "recommendation({ endpoint })");
    assertEndpointId(opts.endpoint, "recommendation({ endpoint })");
    assertNotUndefined(opts.fanout, "recommendation({ fanout })");
    assertInteger(opts.fanout, "recommendation({ fanout })");
    const { extensions, ...rest } = opts;
    checkNoUndefined(rest, "recommendation(opts)");
    // Validate trace
    if (opts.trace !== undefined) {
        assertStringOrNull(opts.trace, "recommendation({ trace })");
    }
    const params = {
        endpoint: opts.endpoint,
        fanout: opts.fanout,
        trace: opts.trace ?? null,
    };
    return ctx.addNode("core::recommendation", [inputNodeId], params, extensions);
}
/** Implementation for core::sort */
export function sortImpl(ctx, inputNodeId, opts) {
    assertNotUndefined(opts, "sort(opts)");
    assertNotUndefined(opts.by, "sort({ by })");
    assertKeyToken(opts.by, "sort({ by })");
    const { extensions, ...rest } = opts;
    checkNoUndefined(rest, "sort(opts)");
    // Validate trace
    if (opts.trace !== undefined) {
        assertStringOrNull(opts.trace, "sort({ trace })");
    }
    const params = {
        by: opts.by.id,
        order: opts.order,
        trace: opts.trace ?? null,
    };
    return ctx.addNode("core::sort", [inputNodeId], params, extensions);
}
/** Implementation for core::take */
export function takeImpl(ctx, inputNodeId, opts) {
    assertNotUndefined(opts, "take(opts)");
    assertNotUndefined(opts.count, "take({ count })");
    assertInteger(opts.count, "take({ count })");
    const { extensions, ...rest } = opts;
    checkNoUndefined(rest, "take(opts)");
    // Validate trace
    if (opts.trace !== undefined) {
        assertStringOrNull(opts.trace, "take({ trace })");
    }
    const params = {
        count: opts.count,
        trace: opts.trace ?? null,
    };
    return ctx.addNode("core::take", [inputNodeId], params, extensions);
}
/** Implementation for core::vm */
export function vmImpl(ctx, inputNodeId, opts) {
    assertNotUndefined(opts, "vm(opts)");
    assertNotUndefined(opts.expr, "vm({ expr })");
    assertNotUndefined(opts.outKey, "vm({ outKey })");
    assertKeyToken(opts.outKey, "vm({ outKey })");
    const { extensions, ...rest } = opts;
    checkNoUndefined(rest, "vm(opts)");
    // Validate trace
    if (opts.trace !== undefined) {
        assertStringOrNull(opts.trace, "vm({ trace })");
    }
    // Validate and handle expression table
    assertExprInput(opts.expr, "vm({ expr })");
    let exprId;
    if (isExprPlaceholder(opts.expr)) {
        // AST-extracted expression - use special prefix for later remapping
        exprId = `__static_e${opts.expr.__expr_id}`;
    }
    else {
        // Regular builder-style expression
        exprId = ctx.addExpr(opts.expr);
    }
    const params = {
        expr_id: exprId,
        out_key: opts.outKey.id,
        trace: opts.trace ?? null,
    };
    return ctx.addNode("core::vm", [inputNodeId], params, extensions);
}
/** Implementation for test::busy_cpu */
export function busyCpuImpl(ctx, inputNodeId, opts) {
    assertNotUndefined(opts, "busyCpu(opts)");
    assertNotUndefined(opts.busyWaitMs, "busyCpu({ busyWaitMs })");
    assertInteger(opts.busyWaitMs, "busyCpu({ busyWaitMs })");
    const { extensions, ...rest } = opts;
    checkNoUndefined(rest, "busyCpu(opts)");
    // Validate trace
    if (opts.trace !== undefined) {
        assertStringOrNull(opts.trace, "busyCpu({ trace })");
    }
    const params = {
        busy_wait_ms: opts.busyWaitMs,
        trace: opts.trace ?? null,
    };
    return ctx.addNode("test::busy_cpu", [inputNodeId], params, extensions);
}
/** Implementation for test::fixed_source */
export function fixedSourceImpl(ctx, inputNodeId, opts) {
    assertNotUndefined(opts, "fixedSource(opts)");
    const { extensions, ...rest } = opts;
    checkNoUndefined(rest, "fixedSource(opts)");
    // Validate trace
    if (opts.trace !== undefined) {
        assertStringOrNull(opts.trace, "fixedSource({ trace })");
    }
    const params = {
        row_count: opts.rowCount,
        trace: opts.trace ?? null,
    };
    return ctx.addNode("test::fixed_source", [inputNodeId], params, extensions);
}
/** Implementation for test::sleep */
export function sleepImpl(ctx, inputNodeId, opts) {
    assertNotUndefined(opts, "sleep(opts)");
    assertNotUndefined(opts.durationMs, "sleep({ durationMs })");
    assertInteger(opts.durationMs, "sleep({ durationMs })");
    const { extensions, ...rest } = opts;
    checkNoUndefined(rest, "sleep(opts)");
    // Validate trace
    if (opts.trace !== undefined) {
        assertStringOrNull(opts.trace, "sleep({ trace })");
    }
    const params = {
        duration_ms: opts.durationMs,
        fail_after_sleep: opts.failAfterSleep,
        trace: opts.trace ?? null,
    };
    return ctx.addNode("test::sleep", [inputNodeId], params, extensions);
}
// =====================================================
// Task metadata for runtime use
// =====================================================
export const GENERATED_TASKS = {
    source: ["viewer"],
    core: ["concat", "filter", "follow", "media", "recommendation", "sort", "take", "vm"],
    test: ["busyCpu", "fixedSource", "sleep"],
};
