// AUTO-GENERATED from C++ TaskSpec - DO NOT EDIT
// Generated by dsl/src/codegen.ts from registry/tasks.toml
// Regenerate with: pnpm -C dsl run gen
// ============================================================
// Types for plan context interface
// ============================================================
/** Interface for expression placeholder detection */
export function isExprPlaceholder(value) {
    return (value !== null &&
        typeof value === "object" &&
        "__expr_id" in value &&
        typeof value.__expr_id === "number");
}
// ============================================================
// Validation helpers
// ============================================================
function assertNotUndefined(value, name) {
    if (value === undefined)
        throw new Error(`${name} is undefined`);
}
function checkNoUndefined(obj, context) {
    for (const [key, value] of Object.entries(obj)) {
        if (value === undefined) {
            throw new Error(`${context}.${key} is undefined`);
        }
        // Recursively check nested objects (but not arrays)
        if (typeof value === "object" && value !== null && !Array.isArray(value)) {
            checkNoUndefined(value, `${context}.${key}`);
        }
    }
}
// ============================================================
// Source task implementations (for PlanCtx.viewer)
// ============================================================
/** Implementation for viewer.fetch_cached_recommendation */
export function fetch_cached_recommendationImpl(ctx, opts) {
    assertNotUndefined(opts, "fetch_cached_recommendation(opts)");
    assertNotUndefined(opts.fanout, "fetch_cached_recommendation({ fanout })");
    const { extensions, ...rest } = opts;
    checkNoUndefined(rest, "fetch_cached_recommendation(opts)");
    const params = {
        fanout: opts.fanout,
        trace: opts.trace ?? null,
    };
    return ctx.addNode("viewer.fetch_cached_recommendation", [], params, extensions);
}
/** Implementation for viewer.follow */
export function followImpl(ctx, opts) {
    assertNotUndefined(opts, "follow(opts)");
    assertNotUndefined(opts.fanout, "follow({ fanout })");
    const { extensions, ...rest } = opts;
    checkNoUndefined(rest, "follow(opts)");
    const params = {
        fanout: opts.fanout,
        trace: opts.trace ?? null,
    };
    return ctx.addNode("viewer.follow", [], params, extensions);
}
// ============================================================
// Transform task implementations (for CandidateSet methods)
// ============================================================
/** Implementation for concat */
export function concatImpl(ctx, lhsNodeId, rhsNodeId, opts) {
    let extensions;
    if (opts !== undefined) {
        const { extensions: ext, ...rest } = opts;
        extensions = ext;
        checkNoUndefined(rest, "concat(opts)");
    }
    const params = {
        trace: opts?.trace ?? null,
    };
    return ctx.addNode("concat", [lhsNodeId, rhsNodeId], params, extensions);
}
/** Implementation for filter */
export function filterImpl(ctx, inputNodeId, opts) {
    assertNotUndefined(opts, "filter(opts)");
    assertNotUndefined(opts.pred, "filter({ pred })");
    const { extensions, ...rest } = opts;
    checkNoUndefined(rest, "filter(opts)");
    // Handle predicate table
    const predId = ctx.addPred(opts.pred);
    const params = {
        pred_id: predId,
        trace: opts.trace ?? null,
    };
    return ctx.addNode("filter", [inputNodeId], params, extensions);
}
/** Implementation for take */
export function takeImpl(ctx, inputNodeId, opts) {
    assertNotUndefined(opts, "take(opts)");
    assertNotUndefined(opts.count, "take({ count })");
    const { extensions, ...rest } = opts;
    checkNoUndefined(rest, "take(opts)");
    const params = {
        count: opts.count,
        trace: opts.trace ?? null,
    };
    return ctx.addNode("take", [inputNodeId], params, extensions);
}
/** Implementation for vm */
export function vmImpl(ctx, inputNodeId, opts) {
    assertNotUndefined(opts, "vm(opts)");
    assertNotUndefined(opts.expr, "vm({ expr })");
    assertNotUndefined(opts.outKey, "vm({ outKey })");
    const { extensions, ...rest } = opts;
    checkNoUndefined(rest, "vm(opts)");
    // Handle expression table
    let exprId;
    if (isExprPlaceholder(opts.expr)) {
        // AST-extracted expression - use special prefix for later remapping
        exprId = `__static_e${opts.expr.__expr_id}`;
    }
    else {
        // Regular builder-style expression
        exprId = ctx.addExpr(opts.expr);
    }
    const params = {
        expr_id: exprId,
        out_key: opts.outKey.id,
        trace: opts.trace ?? null,
    };
    return ctx.addNode("vm", [inputNodeId], params, extensions);
}
// ============================================================
// Task metadata for runtime use
// ============================================================
export const GENERATED_TASKS = {
    source: ["fetch_cached_recommendation", "follow"],
    transform: ["concat", "filter", "take", "vm"],
};
