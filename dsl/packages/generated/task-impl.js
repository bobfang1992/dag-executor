// AUTO-GENERATED from C++ TaskSpec - DO NOT EDIT
// Generated by dsl/src/codegen.ts from registry/tasks.toml
// Regenerate with: pnpm -C dsl run gen
// ============================================================
// Types for plan context interface
// ============================================================
/** Interface for expression placeholder detection */
export function isExprPlaceholder(value) {
    return (value !== null &&
        typeof value === "object" &&
        "__expr_id" in value &&
        typeof value.__expr_id === "number");
}
// ============================================================
// Validation helpers
// ============================================================
function assertNotUndefined(value, name) {
    if (value === undefined)
        throw new Error(`${name} is undefined`);
}
function assertInteger(value, name) {
    if (typeof value !== "number" || !Number.isInteger(value)) {
        throw new Error(`${name} must be an integer, got ${typeof value === "number" ? value : typeof value}`);
    }
}
function assertKeyToken(value, name) {
    if (value === null || typeof value !== "object") {
        throw new Error(`${name} must be a KeyToken, got ${value === null ? "null" : typeof value}`);
    }
    const token = value;
    if (typeof token.id !== "number" || !Number.isInteger(token.id)) {
        throw new Error(`${name}.id must be an integer, got ${typeof token.id === "number" ? token.id : typeof token.id}`);
    }
}
function assertStringOrNull(value, name) {
    if (value !== null && typeof value !== "string") {
        throw new Error(`${name} must be a string or null, got ${typeof value}`);
    }
}
function assertExprInput(value, name) {
    if (value === null || typeof value !== "object") {
        throw new Error(`${name} must be an ExprNode or ExprPlaceholder, got ${value === null ? "null" : typeof value}`);
    }
    const obj = value;
    // ExprPlaceholder has __expr_id, ExprNode has op
    if (typeof obj.__expr_id !== "number" && typeof obj.op !== "string") {
        throw new Error(`${name} must be an ExprNode (with 'op') or ExprPlaceholder (with '__expr_id')`);
    }
}
function assertPredNode(value, name) {
    if (value === null || typeof value !== "object") {
        throw new Error(`${name} must be a PredNode, got ${value === null ? "null" : typeof value}`);
    }
    const obj = value;
    if (typeof obj.op !== "string") {
        throw new Error(`${name} must be a PredNode with 'op' field`);
    }
}
function checkNoUndefined(obj, context) {
    for (const [key, value] of Object.entries(obj)) {
        if (value === undefined) {
            throw new Error(`${context}.${key} is undefined`);
        }
        // Recursively check nested objects (but not arrays)
        if (typeof value === "object" && value !== null && !Array.isArray(value)) {
            checkNoUndefined(value, `${context}.${key}`);
        }
    }
}
// ============================================================
// Source task implementations (for PlanCtx.viewer)
// ============================================================
/** Implementation for viewer.fetch_cached_recommendation */
export function fetch_cached_recommendationImpl(ctx, opts) {
    assertNotUndefined(opts, "fetch_cached_recommendation(opts)");
    assertNotUndefined(opts.fanout, "fetch_cached_recommendation({ fanout })");
    assertInteger(opts.fanout, "fetch_cached_recommendation({ fanout })");
    const { extensions, ...rest } = opts;
    checkNoUndefined(rest, "fetch_cached_recommendation(opts)");
    // Validate trace
    if (opts.trace !== undefined) {
        assertStringOrNull(opts.trace, "fetch_cached_recommendation({ trace })");
    }
    const params = {
        fanout: opts.fanout,
        trace: opts.trace ?? null,
    };
    return ctx.addNode("viewer.fetch_cached_recommendation", [], params, extensions);
}
/** Implementation for viewer.follow */
export function followImpl(ctx, opts) {
    assertNotUndefined(opts, "follow(opts)");
    assertNotUndefined(opts.fanout, "follow({ fanout })");
    assertInteger(opts.fanout, "follow({ fanout })");
    const { extensions, ...rest } = opts;
    checkNoUndefined(rest, "follow(opts)");
    // Validate trace
    if (opts.trace !== undefined) {
        assertStringOrNull(opts.trace, "follow({ trace })");
    }
    const params = {
        fanout: opts.fanout,
        trace: opts.trace ?? null,
    };
    return ctx.addNode("viewer.follow", [], params, extensions);
}
// ============================================================
// Transform task implementations (for CandidateSet methods)
// ============================================================
/** Implementation for concat */
export function concatImpl(ctx, lhsNodeId, rhsNodeId, opts) {
    let extensions;
    if (opts !== undefined) {
        const { extensions: ext, ...rest } = opts;
        extensions = ext;
        checkNoUndefined(rest, "concat(opts)");
    }
    // Validate trace
    if (opts?.trace !== undefined) {
        assertStringOrNull(opts?.trace, "concat({ trace })");
    }
    const params = {
        trace: opts?.trace ?? null,
    };
    return ctx.addNode("concat", [lhsNodeId, rhsNodeId], params, extensions);
}
/** Implementation for filter */
export function filterImpl(ctx, inputNodeId, opts) {
    assertNotUndefined(opts, "filter(opts)");
    assertNotUndefined(opts.pred, "filter({ pred })");
    const { extensions, ...rest } = opts;
    checkNoUndefined(rest, "filter(opts)");
    // Validate trace
    if (opts.trace !== undefined) {
        assertStringOrNull(opts.trace, "filter({ trace })");
    }
    // Validate and handle predicate table
    assertPredNode(opts.pred, "filter({ pred })");
    const predId = ctx.addPred(opts.pred);
    const params = {
        pred_id: predId,
        trace: opts.trace ?? null,
    };
    return ctx.addNode("filter", [inputNodeId], params, extensions);
}
/** Implementation for take */
export function takeImpl(ctx, inputNodeId, opts) {
    assertNotUndefined(opts, "take(opts)");
    assertNotUndefined(opts.count, "take({ count })");
    assertInteger(opts.count, "take({ count })");
    const { extensions, ...rest } = opts;
    checkNoUndefined(rest, "take(opts)");
    // Validate trace
    if (opts.trace !== undefined) {
        assertStringOrNull(opts.trace, "take({ trace })");
    }
    const params = {
        count: opts.count,
        trace: opts.trace ?? null,
    };
    return ctx.addNode("take", [inputNodeId], params, extensions);
}
/** Implementation for vm */
export function vmImpl(ctx, inputNodeId, opts) {
    assertNotUndefined(opts, "vm(opts)");
    assertNotUndefined(opts.expr, "vm({ expr })");
    assertNotUndefined(opts.outKey, "vm({ outKey })");
    assertKeyToken(opts.outKey, "vm({ outKey })");
    const { extensions, ...rest } = opts;
    checkNoUndefined(rest, "vm(opts)");
    // Validate trace
    if (opts.trace !== undefined) {
        assertStringOrNull(opts.trace, "vm({ trace })");
    }
    // Validate and handle expression table
    assertExprInput(opts.expr, "vm({ expr })");
    let exprId;
    if (isExprPlaceholder(opts.expr)) {
        // AST-extracted expression - use special prefix for later remapping
        exprId = `__static_e${opts.expr.__expr_id}`;
    }
    else {
        // Regular builder-style expression
        exprId = ctx.addExpr(opts.expr);
    }
    const params = {
        expr_id: exprId,
        out_key: opts.outKey.id,
        trace: opts.trace ?? null,
    };
    return ctx.addNode("vm", [inputNodeId], params, extensions);
}
// ============================================================
// Task metadata for runtime use
// ============================================================
export const GENERATED_TASKS = {
    source: ["fetch_cached_recommendation", "follow"],
    transform: ["concat", "filter", "take", "vm"],
};
