// AUTO-GENERATED from C++ TaskSpec - DO NOT EDIT
// Generated by dsl/src/codegen.ts from registry/tasks.toml
// Regenerate with: pnpm -C dsl run gen

// This file contains the generated task implementations.
// It is used by plan.ts to implement task methods without manual code.

import type { ExprNode, ExprPlaceholder, ExprInput, PredNode, PredPlaceholder, PredInput, CandidateSetLike } from "./tasks.js";
import type { KeyToken } from "./keys.js";

// =====================================================
// Types for plan context interface
// =====================================================

/** Interface for expression placeholder detection */
export function isExprPlaceholder(value: unknown): value is ExprPlaceholder {
  return (
    value !== null &&
    typeof value === "object" &&
    "__expr_id" in value &&
    typeof (value as ExprPlaceholder).__expr_id === "number"
  );
}

/** Interface for predicate placeholder detection */
export function isPredPlaceholder(value: unknown): value is PredPlaceholder {
  return (
    value !== null &&
    typeof value === "object" &&
    "__pred_id" in value &&
    typeof (value as PredPlaceholder).__pred_id === "number"
  );
}

/** Interface that PlanCtx must implement for task impls to use */
export interface TaskContext {
  addNode(
    op: string,
    inputs: string[],
    params: Record<string, unknown>,
    extensions?: Record<string, unknown>
  ): string;
  addExpr(expr: ExprNode): string;
  addPred(pred: PredNode): string;
}

// =====================================================
// Validation helpers
// =====================================================

function assertNotUndefined<T>(value: T | undefined, name: string): asserts value is T {
  if (value === undefined) throw new Error(`${name} is undefined`);
}

function assertInteger(value: unknown, name: string): asserts value is number {
  if (typeof value !== "number" || !Number.isInteger(value)) {
    throw new Error(`${name} must be an integer, got ${typeof value === "number" ? value : typeof value}`);
  }
}

function assertKeyToken(value: unknown, name: string): void {
  if (value === null || typeof value !== "object") {
    throw new Error(`${name} must be a KeyToken, got ${value === null ? "null" : typeof value}`);
  }
  const token = value as Record<string, unknown>;
  if (typeof token.id !== "number" || !Number.isInteger(token.id)) {
    throw new Error(`${name}.id must be an integer, got ${typeof token.id === "number" ? token.id : typeof token.id}`);
  }
}

function assertStringOrNull(value: unknown, name: string): void {
  if (value !== null && typeof value !== "string") {
    throw new Error(`${name} must be a string or null, got ${typeof value}`);
  }
}

function assertExprInput(value: unknown, name: string): void {
  if (value === null || typeof value !== "object") {
    throw new Error(`${name} must be an ExprNode or ExprPlaceholder, got ${value === null ? "null" : typeof value}`);
  }
  const obj = value as Record<string, unknown>;
  // ExprPlaceholder has __expr_id, ExprNode has op
  if (typeof obj.__expr_id !== "number" && typeof obj.op !== "string") {
    throw new Error(`${name} must be an ExprNode (with 'op') or ExprPlaceholder (with '__expr_id')`);
  }
}

function assertPredInput(value: unknown, name: string): void {
  if (value === null || typeof value !== "object") {
    throw new Error(`${name} must be a PredNode or PredPlaceholder, got ${value === null ? "null" : typeof value}`);
  }
  const obj = value as Record<string, unknown>;
  // PredPlaceholder has __pred_id, PredNode has op
  if (typeof obj.__pred_id !== "number" && typeof obj.op !== "string") {
    throw new Error(`${name} must be a PredNode (with 'op') or PredPlaceholder (with '__pred_id')`);
  }
}

function assertCandidateSet(value: unknown, name: string): void {
  if (value === null || typeof value !== "object") {
    throw new Error(`${name} must be a CandidateSet, got ${value === null ? "null" : typeof value}`);
  }
  const obj = value as Record<string, unknown>;
  if (typeof obj.getNodeId !== "function") {
    throw new Error(`${name} must be a CandidateSet with 'getNodeId' method`);
  }
}

function checkNoUndefined(obj: Record<string, unknown>, context: string): void {
  for (const [key, value] of Object.entries(obj)) {
    if (value === undefined) {
      throw new Error(`${context}.${key} is undefined`);
    }
    // Recursively check nested objects (but not arrays)
    if (typeof value === "object" && value !== null && !Array.isArray(value)) {
      checkNoUndefined(value as Record<string, unknown>, `${context}.${key}`);
    }
  }
}

// =====================================================
// Source task implementations (for PlanCtx.viewer)
// =====================================================

/** Implementation for viewer.fetch_cached_recommendation */
export function fetchCachedRecommendationImpl(
  ctx: TaskContext,
  opts: {
    fanout: number;
    trace?: string | null;
    extensions?: Record<string, unknown>;
  }
): string {
  assertNotUndefined(opts, "fetchCachedRecommendation(opts)");
  assertNotUndefined(opts.fanout, "fetchCachedRecommendation({ fanout })");
  assertInteger(opts.fanout, "fetchCachedRecommendation({ fanout })");
  const { extensions, ...rest } = opts;
  checkNoUndefined(rest as Record<string, unknown>, "fetchCachedRecommendation(opts)");

  // Validate trace
  if (opts.trace !== undefined) {
    assertStringOrNull(opts.trace, "fetchCachedRecommendation({ trace })");
  }

  const params: Record<string, unknown> = {
    fanout: opts.fanout,
    trace: opts.trace ?? null,
  };

  return ctx.addNode("viewer.fetch_cached_recommendation", [], params, extensions);
}

/** Implementation for viewer.follow */
export function followImpl(
  ctx: TaskContext,
  opts: {
    fanout: number;
    trace?: string | null;
    extensions?: Record<string, unknown>;
  }
): string {
  assertNotUndefined(opts, "follow(opts)");
  assertNotUndefined(opts.fanout, "follow({ fanout })");
  assertInteger(opts.fanout, "follow({ fanout })");
  const { extensions, ...rest } = opts;
  checkNoUndefined(rest as Record<string, unknown>, "follow(opts)");

  // Validate trace
  if (opts.trace !== undefined) {
    assertStringOrNull(opts.trace, "follow({ trace })");
  }

  const params: Record<string, unknown> = {
    fanout: opts.fanout,
    trace: opts.trace ?? null,
  };

  return ctx.addNode("viewer.follow", [], params, extensions);
}

// =====================================================
// Transform task implementations (for CandidateSet methods)
// =====================================================

/** Implementation for concat */
export function concatImpl(
  ctx: TaskContext,
  inputNodeId: string,
  opts: {
    rhs: CandidateSetLike;
    trace?: string | null;
    extensions?: Record<string, unknown>;
  }
): string {
  assertNotUndefined(opts, "concat(opts)");
  assertNotUndefined(opts.rhs, "concat({ rhs })");
  assertCandidateSet(opts.rhs, "concat({ rhs })");
  const { extensions, ...rest } = opts;
  checkNoUndefined(rest as Record<string, unknown>, "concat(opts)");

  // Validate trace
  if (opts.trace !== undefined) {
    assertStringOrNull(opts.trace, "concat({ trace })");
  }

  const params: Record<string, unknown> = {
    rhs: opts.rhs.getNodeId(),
    trace: opts.trace ?? null,
  };

  return ctx.addNode("concat", [inputNodeId], params, extensions);
}

/** Implementation for filter */
export function filterImpl(
  ctx: TaskContext,
  inputNodeId: string,
  opts: {
    pred: PredInput;
    trace?: string | null;
    extensions?: Record<string, unknown>;
  }
): string {
  assertNotUndefined(opts, "filter(opts)");
  assertNotUndefined(opts.pred, "filter({ pred })");
  const { extensions, ...rest } = opts;
  checkNoUndefined(rest as Record<string, unknown>, "filter(opts)");

  // Validate trace
  if (opts.trace !== undefined) {
    assertStringOrNull(opts.trace, "filter({ trace })");
  }

  // Validate and handle predicate table
  assertPredInput(opts.pred, "filter({ pred })");
  let predId: string;
  if (isPredPlaceholder(opts.pred)) {
    // AST-extracted predicate - use special prefix for later remapping
    predId = `__static_p${opts.pred.__pred_id}`;
  } else {
    // Regular builder-style predicate
    predId = ctx.addPred(opts.pred as PredNode);
  }

  const params: Record<string, unknown> = {
    pred_id: predId,
    trace: opts.trace ?? null,
  };

  return ctx.addNode("filter", [inputNodeId], params, extensions);
}

/** Implementation for sort */
export function sortImpl(
  ctx: TaskContext,
  inputNodeId: string,
  opts: {
    by: number;
    order?: string;
    trace?: string | null;
    extensions?: Record<string, unknown>;
  }
): string {
  assertNotUndefined(opts, "sort(opts)");
  assertNotUndefined(opts.by, "sort({ by })");
  assertInteger(opts.by, "sort({ by })");
  const { extensions, ...rest } = opts;
  checkNoUndefined(rest as Record<string, unknown>, "sort(opts)");

  // Validate trace
  if (opts.trace !== undefined) {
    assertStringOrNull(opts.trace, "sort({ trace })");
  }

  const params: Record<string, unknown> = {
    by: opts.by,
    order: opts.order,
    trace: opts.trace ?? null,
  };

  return ctx.addNode("sort", [inputNodeId], params, extensions);
}

/** Implementation for take */
export function takeImpl(
  ctx: TaskContext,
  inputNodeId: string,
  opts: {
    count: number;
    trace?: string | null;
    extensions?: Record<string, unknown>;
  }
): string {
  assertNotUndefined(opts, "take(opts)");
  assertNotUndefined(opts.count, "take({ count })");
  assertInteger(opts.count, "take({ count })");
  const { extensions, ...rest } = opts;
  checkNoUndefined(rest as Record<string, unknown>, "take(opts)");

  // Validate trace
  if (opts.trace !== undefined) {
    assertStringOrNull(opts.trace, "take({ trace })");
  }

  const params: Record<string, unknown> = {
    count: opts.count,
    trace: opts.trace ?? null,
  };

  return ctx.addNode("take", [inputNodeId], params, extensions);
}

/** Implementation for vm */
export function vmImpl(
  ctx: TaskContext,
  inputNodeId: string,
  opts: {
    expr: ExprInput;
    outKey: KeyToken;
    trace?: string | null;
    extensions?: Record<string, unknown>;
  }
): string {
  assertNotUndefined(opts, "vm(opts)");
  assertNotUndefined(opts.expr, "vm({ expr })");
  assertNotUndefined(opts.outKey, "vm({ outKey })");
  assertKeyToken(opts.outKey, "vm({ outKey })");
  const { extensions, ...rest } = opts;
  checkNoUndefined(rest as Record<string, unknown>, "vm(opts)");

  // Validate trace
  if (opts.trace !== undefined) {
    assertStringOrNull(opts.trace, "vm({ trace })");
  }

  // Validate and handle expression table
  assertExprInput(opts.expr, "vm({ expr })");
  let exprId: string;
  if (isExprPlaceholder(opts.expr)) {
    // AST-extracted expression - use special prefix for later remapping
    exprId = `__static_e${opts.expr.__expr_id}`;
  } else {
    // Regular builder-style expression
    exprId = ctx.addExpr(opts.expr as ExprNode);
  }

  const params: Record<string, unknown> = {
    expr_id: exprId,
    out_key: opts.outKey.id,
    trace: opts.trace ?? null,
  };

  return ctx.addNode("vm", [inputNodeId], params, extensions);
}

// =====================================================
// Task metadata for runtime use
// =====================================================

export const GENERATED_TASKS = {
  source: ["fetchCachedRecommendation", "follow"],
  transform: ["concat", "filter", "sort", "take", "vm"],
} as const;
