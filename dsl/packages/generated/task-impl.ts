// AUTO-GENERATED from C++ TaskSpec - DO NOT EDIT
// Generated by dsl/src/codegen.ts from registry/tasks.toml
// Regenerate with: pnpm -C dsl run gen

// This file contains the generated task implementations.
// It is used by plan.ts to implement task methods without manual code.

import type { ExprNode, ExprPlaceholder, ExprInput, PredNode } from "./tasks.js";
import type { KeyToken } from "./keys.js";

// =====================================================
// Types for plan context interface
// =====================================================

/** Interface for expression placeholder detection */
export function isExprPlaceholder(value: unknown): value is ExprPlaceholder {
  return (
    value !== null &&
    typeof value === "object" &&
    "__expr_id" in value &&
    typeof (value as ExprPlaceholder).__expr_id === "number"
  );
}

/** Interface that PlanCtx must implement for task impls to use */
export interface TaskContext {
  addNode(
    op: string,
    inputs: string[],
    params: Record<string, unknown>,
    extensions?: Record<string, unknown>
  ): string;
  addExpr(expr: ExprNode): string;
  addPred(pred: PredNode): string;
}

// =====================================================
// Validation helpers
// =====================================================

function assertNotUndefined<T>(value: T | undefined, name: string): asserts value is T {
  if (value === undefined) throw new Error(`${name} is undefined`);
}

function assertInteger(value: unknown, name: string): asserts value is number {
  if (typeof value !== "number" || !Number.isInteger(value)) {
    throw new Error(`${name} must be an integer, got ${typeof value === "number" ? value : typeof value}`);
  }
}

function assertKeyToken(value: unknown, name: string): void {
  if (value === null || typeof value !== "object") {
    throw new Error(`${name} must be a KeyToken, got ${value === null ? "null" : typeof value}`);
  }
  const token = value as Record<string, unknown>;
  if (typeof token.id !== "number" || !Number.isInteger(token.id)) {
    throw new Error(`${name}.id must be an integer, got ${typeof token.id === "number" ? token.id : typeof token.id}`);
  }
}

function assertStringOrNull(value: unknown, name: string): void {
  if (value !== null && typeof value !== "string") {
    throw new Error(`${name} must be a string or null, got ${typeof value}`);
  }
}

function assertExprInput(value: unknown, name: string): void {
  if (value === null || typeof value !== "object") {
    throw new Error(`${name} must be an ExprNode or ExprPlaceholder, got ${value === null ? "null" : typeof value}`);
  }
  const obj = value as Record<string, unknown>;
  // ExprPlaceholder has __expr_id, ExprNode has op
  if (typeof obj.__expr_id !== "number" && typeof obj.op !== "string") {
    throw new Error(`${name} must be an ExprNode (with 'op') or ExprPlaceholder (with '__expr_id')`);
  }
}

function assertPredNode(value: unknown, name: string): void {
  if (value === null || typeof value !== "object") {
    throw new Error(`${name} must be a PredNode, got ${value === null ? "null" : typeof value}`);
  }
  const obj = value as Record<string, unknown>;
  if (typeof obj.op !== "string") {
    throw new Error(`${name} must be a PredNode with 'op' field`);
  }
}

function checkNoUndefined(obj: Record<string, unknown>, context: string): void {
  for (const [key, value] of Object.entries(obj)) {
    if (value === undefined) {
      throw new Error(`${context}.${key} is undefined`);
    }
    // Recursively check nested objects (but not arrays)
    if (typeof value === "object" && value !== null && !Array.isArray(value)) {
      checkNoUndefined(value as Record<string, unknown>, `${context}.${key}`);
    }
  }
}

// =====================================================
// Source task implementations (for PlanCtx.viewer)
// =====================================================

/** Implementation for viewer.fetch_cached_recommendation */
export function fetch_cached_recommendationImpl(
  ctx: TaskContext,
  opts: {
    fanout: number;
    trace?: string | null;
    extensions?: Record<string, unknown>;
  }
): string {
  assertNotUndefined(opts, "fetch_cached_recommendation(opts)");
  assertNotUndefined(opts.fanout, "fetch_cached_recommendation({ fanout })");
  assertInteger(opts.fanout, "fetch_cached_recommendation({ fanout })");
  const { extensions, ...rest } = opts;
  checkNoUndefined(rest as Record<string, unknown>, "fetch_cached_recommendation(opts)");

  // Validate trace
  if (opts.trace !== undefined) {
    assertStringOrNull(opts.trace, "fetch_cached_recommendation({ trace })");
  }

  const params: Record<string, unknown> = {
    fanout: opts.fanout,
    trace: opts.trace ?? null,
  };

  return ctx.addNode("viewer.fetch_cached_recommendation", [], params, extensions);
}

/** Implementation for viewer.follow */
export function followImpl(
  ctx: TaskContext,
  opts: {
    fanout: number;
    trace?: string | null;
    extensions?: Record<string, unknown>;
  }
): string {
  assertNotUndefined(opts, "follow(opts)");
  assertNotUndefined(opts.fanout, "follow({ fanout })");
  assertInteger(opts.fanout, "follow({ fanout })");
  const { extensions, ...rest } = opts;
  checkNoUndefined(rest as Record<string, unknown>, "follow(opts)");

  // Validate trace
  if (opts.trace !== undefined) {
    assertStringOrNull(opts.trace, "follow({ trace })");
  }

  const params: Record<string, unknown> = {
    fanout: opts.fanout,
    trace: opts.trace ?? null,
  };

  return ctx.addNode("viewer.follow", [], params, extensions);
}

// =====================================================
// Transform task implementations (for CandidateSet methods)
// =====================================================

/** Implementation for concat */
export function concatImpl(
  ctx: TaskContext,
  lhsNodeId: string,
  rhsNodeId: string,
  opts?: {
    trace?: string | null;
    extensions?: Record<string, unknown>;
  }
): string {
  let extensions: Record<string, unknown> | undefined;
  if (opts !== undefined) {
    const { extensions: ext, ...rest } = opts;
    extensions = ext;
    checkNoUndefined(rest as Record<string, unknown>, "concat(opts)");
  }

  // Validate trace
  if (opts?.trace !== undefined) {
    assertStringOrNull(opts?.trace, "concat({ trace })");
  }

  const params: Record<string, unknown> = {
    trace: opts?.trace ?? null,
  };

  return ctx.addNode("concat", [lhsNodeId, rhsNodeId], params, extensions);
}

/** Implementation for filter */
export function filterImpl(
  ctx: TaskContext,
  inputNodeId: string,
  opts: {
    pred: PredNode;
    trace?: string | null;
    extensions?: Record<string, unknown>;
  }
): string {
  assertNotUndefined(opts, "filter(opts)");
  assertNotUndefined(opts.pred, "filter({ pred })");
  const { extensions, ...rest } = opts;
  checkNoUndefined(rest as Record<string, unknown>, "filter(opts)");

  // Validate trace
  if (opts.trace !== undefined) {
    assertStringOrNull(opts.trace, "filter({ trace })");
  }

  // Validate and handle predicate table
  assertPredNode(opts.pred, "filter({ pred })");
  const predId = ctx.addPred(opts.pred);

  const params: Record<string, unknown> = {
    pred_id: predId,
    trace: opts.trace ?? null,
  };

  return ctx.addNode("filter", [inputNodeId], params, extensions);
}

/** Implementation for take */
export function takeImpl(
  ctx: TaskContext,
  inputNodeId: string,
  opts: {
    count: number;
    trace?: string | null;
    extensions?: Record<string, unknown>;
  }
): string {
  assertNotUndefined(opts, "take(opts)");
  assertNotUndefined(opts.count, "take({ count })");
  assertInteger(opts.count, "take({ count })");
  const { extensions, ...rest } = opts;
  checkNoUndefined(rest as Record<string, unknown>, "take(opts)");

  // Validate trace
  if (opts.trace !== undefined) {
    assertStringOrNull(opts.trace, "take({ trace })");
  }

  const params: Record<string, unknown> = {
    count: opts.count,
    trace: opts.trace ?? null,
  };

  return ctx.addNode("take", [inputNodeId], params, extensions);
}

/** Implementation for vm */
export function vmImpl(
  ctx: TaskContext,
  inputNodeId: string,
  opts: {
    expr: ExprInput;
    outKey: KeyToken;
    trace?: string | null;
    extensions?: Record<string, unknown>;
  }
): string {
  assertNotUndefined(opts, "vm(opts)");
  assertNotUndefined(opts.expr, "vm({ expr })");
  assertNotUndefined(opts.outKey, "vm({ outKey })");
  assertKeyToken(opts.outKey, "vm({ outKey })");
  const { extensions, ...rest } = opts;
  checkNoUndefined(rest as Record<string, unknown>, "vm(opts)");

  // Validate trace
  if (opts.trace !== undefined) {
    assertStringOrNull(opts.trace, "vm({ trace })");
  }

  // Validate and handle expression table
  assertExprInput(opts.expr, "vm({ expr })");
  let exprId: string;
  if (isExprPlaceholder(opts.expr)) {
    // AST-extracted expression - use special prefix for later remapping
    exprId = `__static_e${opts.expr.__expr_id}`;
  } else {
    // Regular builder-style expression
    exprId = ctx.addExpr(opts.expr as ExprNode);
  }

  const params: Record<string, unknown> = {
    expr_id: exprId,
    out_key: opts.outKey.id,
    trace: opts.trace ?? null,
  };

  return ctx.addNode("vm", [inputNodeId], params, extensions);
}

// =====================================================
// Task metadata for runtime use
// =====================================================

export const GENERATED_TASKS = {
  source: ["fetch_cached_recommendation", "follow"],
  transform: ["concat", "filter", "take", "vm"],
} as const;
