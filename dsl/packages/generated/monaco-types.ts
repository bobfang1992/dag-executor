// AUTO-GENERATED from registries - DO NOT EDIT
// Generated by dsl/src/codegen.ts from registry/*.toml
// Regenerate with: pnpm -C dsl run gen

/**
 * Monaco-compatible type definitions for the Ranking DSL.
 * Use with monaco.languages.typescript.typescriptDefaults.addExtraLib()
 */
export const DSL_TYPES = `
declare module '@ranking-dsl/runtime' {
  // =====================================================
  // Token types
  // =====================================================

  export interface KeyToken {
    readonly kind: 'Key';
    readonly id: number;
    readonly name: string;
    // Natural expression support: Key.x * 10, Key.x + Key.y
    // These are compile-time only - the compiler extracts them via AST
    valueOf(): number;
  }

  export interface ParamToken {
    readonly kind: 'Param';
    readonly id: number;
    readonly name: string;
    // Natural expression support: P.weight * 0.5
    valueOf(): number;
  }

  // =====================================================
  // Expression types
  // =====================================================

  export type ExprNode =
    | { op: 'const_number'; value: number }
    | { op: 'const_null' }
    | { op: 'key_ref'; key_id: number }
    | { op: 'param_ref'; param_id: number }
    | { op: 'add'; a: ExprNode; b: ExprNode }
    | { op: 'sub'; a: ExprNode; b: ExprNode }
    | { op: 'mul'; a: ExprNode; b: ExprNode }
    | { op: 'neg'; x: ExprNode }
    | { op: 'coalesce'; a: ExprNode; b: ExprNode };

  // =====================================================
  // Predicate types
  // =====================================================

  export type PredNode =
    | { op: 'const_bool'; value: boolean }
    | { op: 'and'; a: PredNode; b: PredNode }
    | { op: 'or'; a: PredNode; b: PredNode }
    | { op: 'not'; x: PredNode }
    | { op: 'cmp'; cmp: '==' | '!=' | '<' | '<=' | '>' | '>='; a: ExprNode; b: ExprNode }
    | { op: 'in'; lhs: ExprNode; list: (number | string)[] }
    | { op: 'is_null'; x: ExprNode }
    | { op: 'not_null'; x: ExprNode }
    | { op: 'regex'; key_id: number; pattern: { kind: 'literal'; value: string } | { kind: 'param'; param_id: number }; flags: string };

  // =====================================================
  // Expression builder (E)
  // =====================================================

  export const E: {
    const(value: number): ExprNode;
    constNull(): ExprNode;
    key(token: KeyToken): ExprNode;
    param(token: ParamToken): ExprNode;
    add(a: ExprNode, b: ExprNode): ExprNode;
    sub(a: ExprNode, b: ExprNode): ExprNode;
    mul(a: ExprNode, b: ExprNode): ExprNode;
    neg(a: ExprNode): ExprNode;
    coalesce(a: ExprNode, b: ExprNode): ExprNode;
  };

  // =====================================================
  // Predicate builder (Pred)
  // =====================================================

  export const Pred: {
    constBool(value: boolean): PredNode;
    and(a: PredNode, b: PredNode): PredNode;
    or(a: PredNode, b: PredNode): PredNode;
    not(x: PredNode): PredNode;
    cmp(op: '==' | '!=' | '<' | '<=' | '>' | '>=', a: ExprNode, b: ExprNode): PredNode;
    in(lhs: ExprNode, list: (number | string)[]): PredNode;
    isNull(a: ExprNode): PredNode;
    notNull(a: ExprNode): PredNode;
    regex(key: KeyToken, pattern: string | ParamToken, flags?: '' | 'i'): PredNode;
  };

  // =====================================================
  // Plan context and CandidateSet
  // =====================================================

  export interface PlanCtx {
    viewer: {
      fetch_cached_recommendation(opts: { fanout: number; trace?: string }): CandidateSet;
      follow(opts: { fanout: number; trace?: string }): CandidateSet;
    };
    requireCapability(capId: string, payload?: unknown): void;
  }

  export interface CandidateSet {
    concat(opts: { rhs: CandidateSet; trace?: string }): CandidateSet;
    filter(opts: { predId: PredNode; trace?: string }): CandidateSet;
    sort(opts: { by: number; order?: string; trace?: string }): CandidateSet;
    take(opts: { count: number; trace?: string }): CandidateSet;
    vm(opts: { exprId: ExprNode | number; outKey: KeyToken; trace?: string }): CandidateSet;
  }

  export interface PlanConfig {
    name: string;
    build: (ctx: PlanCtx) => CandidateSet;
  }

  export function definePlan(config: PlanConfig): void;

  /**
   * Coalesce function for null handling in natural expressions.
   * Usage: Key.score * coalesce(P.weight, 0.2)
   * Extracted by the compiler at compile-time.
   */
  export function coalesce(a: KeyToken | ParamToken | number | null, b: KeyToken | ParamToken | number): number;

  // =====================================================
  // Key registry (generated from keys.toml)
  // =====================================================

  export const Key: {
    readonly id: KeyToken;
    readonly model_score_1: KeyToken;
    readonly model_score_2: KeyToken;
    readonly final_score: KeyToken;
    readonly country: KeyToken;
    readonly title: KeyToken;
    readonly features_esr: KeyToken;
    readonly features_lsr: KeyToken;
  };

  // =====================================================
  // Param registry (generated from params.toml)
  // =====================================================

  export const P: {
    readonly media_age_penalty_weight: ParamToken;
    readonly blocklist_regex: ParamToken;
    readonly esr_cutoff: ParamToken;
  };
}
`;
