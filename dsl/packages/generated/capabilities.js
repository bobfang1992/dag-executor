// AUTO-GENERATED - DO NOT EDIT
// Generated by dsl/src/codegen.ts from registry/capabilities.toml
export const CAPABILITY_REGISTRY = {
    "cap.rfc.0001.extensions_capabilities.v1": {
        id: "cap.rfc.0001.extensions_capabilities.v1",
        rfc: "0001",
        name: "extensions_capabilities",
        status: "implemented",
        doc: "Base extensions/capabilities mechanism for IR evolution",
        payloadSchema: { "type": "object", "additionalProperties": false },
    },
};
export const SUPPORTED_CAPABILITIES = new Set(Object.entries(CAPABILITY_REGISTRY)
    .filter(([, meta]) => meta.status !== "blocked")
    .map(([id]) => id));
export const CAPABILITY_REGISTRY_DIGEST = "470c3bc1e074d48d7a4e7f7807f44201bfddd4c97e09e575c796f197567dacfa";
export const CAPABILITY_COUNT = 1;
// ============================================================
// Simple JSON Schema validator (subset for capability payloads)
// ============================================================
export function validatePayload(capId, payload) {
    const meta = CAPABILITY_REGISTRY[capId];
    if (!meta)
        return; // Unknown cap handled elsewhere
    const schema = meta.payloadSchema;
    // No schema = no payload allowed
    if (schema === null) {
        if (payload !== undefined && payload !== null) {
            throw new Error(`capability '${capId}': no payload allowed`);
        }
        return;
    }
    // Absent/null payload is OK when schema exists
    if (payload === undefined || payload === null)
        return;
    if (schema.type === "object") {
        if (typeof payload !== "object" || payload === null || Array.isArray(payload)) {
            throw new Error(`capability '${capId}': payload must be object`);
        }
        const obj = payload;
        if (schema.additionalProperties === false) {
            const allowed = new Set(Object.keys(schema.properties ?? {}));
            for (const key of Object.keys(obj)) {
                if (!allowed.has(key)) {
                    throw new Error(`capability '${capId}': unexpected key '${key}'`);
                }
            }
        }
        // Check required properties
        for (const req of schema.required ?? []) {
            if (!(req in obj)) {
                throw new Error(`capability '${capId}': missing required '${req}'`);
            }
        }
        // Type-check properties
        for (const [key, propSchema] of Object.entries(schema.properties ?? {})) {
            if (key in obj) {
                validatePropertyType(capId, key, obj[key], propSchema);
            }
        }
    }
}
function validatePropertyType(capId, key, value, schema) {
    if (schema.type === "boolean" && typeof value !== "boolean") {
        throw new Error(`capability '${capId}': '${key}' must be boolean`);
    }
    if (schema.type === "string" && typeof value !== "string") {
        throw new Error(`capability '${capId}': '${key}' must be string`);
    }
    if (schema.type === "number" && typeof value !== "number") {
        throw new Error(`capability '${capId}': '${key}' must be number`);
    }
}
