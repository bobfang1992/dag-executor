// AUTO-GENERATED - DO NOT EDIT
// Generated by dsl/src/codegen.ts from registry/capabilities.toml
// Capability constants
export const CAP_RFC_0001_EXTENSIONS_CAPABILITIES_V1 = "cap.rfc.0001.extensions_capabilities.v1";
export const CAP_RFC_0005_KEY_EFFECTS_WRITES_EXACT_V1 = "cap.rfc.0005.key_effects_writes_exact.v1";
export const CapabilityRegistry = {
    "cap.rfc.0001.extensions_capabilities.v1": {
        id: "cap.rfc.0001.extensions_capabilities.v1",
        rfc: "0001",
        name: "extensions_capabilities",
        status: "implemented",
        doc: "Base extensions/capabilities mechanism for IR evolution",
        payload_schema: { "type": "object", "additionalProperties": false },
    },
    "cap.rfc.0005.key_effects_writes_exact.v1": {
        id: "cap.rfc.0005.key_effects_writes_exact.v1",
        rfc: "0005",
        name: "key_effects_writes_exact",
        status: "draft",
        doc: "Strict shape enforcement for branching meta-tasks (RFC0005)",
        payload_schema: { "type": "object", "additionalProperties": false },
    },
};
export const ALL_CAPABILITY_IDS = [
    "cap.rfc.0001.extensions_capabilities.v1",
    "cap.rfc.0005.key_effects_writes_exact.v1",
];
/** Set of capability IDs that are supported (implemented + deprecated for backwards compat) */
export const SUPPORTED_CAPABILITIES = new Set([
    "cap.rfc.0001.extensions_capabilities.v1",
]);
export const CAPABILITY_REGISTRY_DIGEST = "3537d0e4f5fe759dd852f53a81972534f50d14cb6e6a7772b5bf12cadb81d4c8";
export const CAPABILITY_COUNT = 2;
/**
 * Validate that a capability payload matches its schema.
 * Returns null if valid, error message if invalid.
 */
export function validatePayload(capId, payload) {
    const meta = CapabilityRegistry[capId];
    if (!meta)
        return `Unknown capability: ${capId}`;
    const schema = meta.payload_schema;
    // null schema means no payload allowed (only undefined/null accepted)
    if (schema === null) {
        if (payload !== undefined && payload !== null) {
            return `Capability ${capId} does not allow a payload`;
        }
        return null;
    }
    // Validate object type (reject arrays, null, non-objects)
    if (schema.type === "object") {
        if (typeof payload !== "object" || payload === null || Array.isArray(payload)) {
            return `Capability ${capId} payload must be an object`;
        }
        const payloadObj = payload;
        const schemaFull = schema;
        // Check additionalProperties: false
        if (schemaFull.additionalProperties === false) {
            const allowedKeys = new Set(schemaFull.properties ? Object.keys(schemaFull.properties) : []);
            for (const key of Object.keys(payloadObj)) {
                if (!allowedKeys.has(key)) {
                    return `Capability ${capId} payload has unexpected property: ${key}`;
                }
            }
        }
        // Check required properties
        if (schemaFull.required) {
            for (const key of schemaFull.required) {
                if (!(key in payloadObj)) {
                    return `Capability ${capId} payload missing required property: ${key}`;
                }
            }
        }
        // Check property types
        if (schemaFull.properties) {
            for (const [key, propSchema] of Object.entries(schemaFull.properties)) {
                if (key in payloadObj && propSchema.type) {
                    const value = payloadObj[key];
                    // typeof null === 'object', so check null explicitly
                    const actualType = value === null ? "null" : Array.isArray(value) ? "array" : typeof value;
                    if (propSchema.type !== actualType) {
                        return `Capability ${capId} payload property ${key} must be ${propSchema.type}, got ${actualType}`;
                    }
                }
            }
        }
    }
    return null;
}
